[
  {
    "module": "component",
    "api": "PushPipe",
    "kind": "ClassDeclaration",
    "signatures": [
      "class PushPipe<S> implements PipeTransform, OnDestroy {\n  transform<T>(\n    potentialObservable: ObservableInput<T> | null | undefined\n  ): T | null | undefined;\n  ngOnDestroy(): void;\n}\n"
    ],
    "information": [
      ["Pipe", "PushPipe"],
      [
        "description",
        "",
        "The `ngrxPush` pipe serves as a drop-in replacement for the `async` pipe.",
        "It contains intelligent handling of change detection to enable us",
        "running in zone-full as well as zone-less mode without any changes to the code.",
        "",
        "The current way of binding an observable to the view looks like that:",
        " ```html",
        " {{observable$ | async}}",
        "<ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>",
        "<component [value]=\"observable$ | async\"></component>",
        "```",
        "",
        "The problem is `async` pipe just marks the component and all its ancestors as dirty.",
        "It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render_creator all dirty marked",
        "    components.",
        "",
        "Heavy dynamic and interactive UIs suffer from zones change detection a lot and can",
        "lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.",
        "",
        "`ngrxPush` pipe solves that problem.",
        "",
        "Included Features:",
        " - Take observables or promises, retrieve their values and render_creator the value to the template",
        " - Handling null and undefined values in a clean unified/structured way",
        " - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)",
        " - Distinct same values in a row to increase performance",
        " - Coalescing of change detection calls to boost performance"
      ],
      [
        "usageNotes",
        "",
        "`ngrxPush` pipe solves that problem. It can be used like shown here:",
        "```html",
        "{{observable$ | ngrxPush}}",
        "<ng-container *ngIf=\"observable$ | ngrxPush as o\">{{o}}</ng-container>",
        "<component [value]=\"observable$ | ngrxPush\"></component>",
        "```"
      ],
      ["publicApi"]
    ]
  },
  {
    "module": "component",
    "api": "LetDirective",
    "kind": "ClassDeclaration",
    "signatures": [
      "class LetDirective<U> implements OnDestroy {\n  static ngTemplateGuard_ngrxLet: 'binding';\n\n  static ngTemplateContextGuard<U>(\n    dir: LetDirective<U>,\n    ctx: unknown | null | undefined\n  ): ctx is LetViewContext<U>;\n  createEmbeddedView();\n  ngOnDestroy();\n}\n"
    ],
    "information": [
      ["Directive", "LetDirective"],
      [
        "description",
        "",
        "The `*ngrxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).",
        "It also helps with several internal processing under the hood.",
        "",
        "The current way of binding an observable to the view looks like that:",
        "```html",
        "<ng-container *ngIf=\"observableNumber$ as n\">",
        "<app-number [number]=\"n\">",
        "</app-number>",
        "<app-number-special [number]=\"n\">",
        "</app-number-special>",
        "</ng-container>",
        " ```",
        "",
        " The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden",
        "",
        "Included Features:",
        "- binding is always present. (`*ngIf=\"truthy$\"`)",
        "- it takes away the multiple usages of the `async` or `ngrxPush` pipe",
        "- a unified/structured way of handling null and undefined",
        "- triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or `ChangeDetectorRef.markForCheck`)",
        "- triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or `ÉµdetectChanges`)",
        "- distinct same values in a row (distinctUntilChanged operator),"
      ],
      [
        "usageNotes",
        "",
        "The `*ngrxLet` directive take over several things and makes it more convenient and save to work with streams in the template",
        "`<ng-container *ngrxLet=\"observableNumber$ as c\"></ng-container>`",
        "",
        "```html",
        "<ng-container *ngrxLet=\"observableNumber$ as n\">",
        "<app-number [number]=\"n\">",
        "</app-number>",
        "</ng-container>",
        "",
        "<ng-container *ngrxLet=\"observableNumber$; let n\">",
        "<app-number [number]=\"n\">",
        "</app-number>",
        "</ng-container>",
        "```",
        "",
        "In addition to that it provides us information from the whole observable context.",
        "We can track the observables:",
        "- next value",
        "- error value",
        "- complete state",
        "",
        "```html",
        "<ng-container *ngrxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">",
        "<app-number [number]=\"n\"  *ngIf=\"!e && !c\">",
        "</app-number>",
        "<ng-container *ngIf=\"e\">",
        "There is an error: {{e}}",
        "</ng-container>",
        "<ng-container *ngIf=\"c\">",
        "Observable completed: {{c}}",
        "</ng-container>",
        "</ng-container>",
        "```"
      ],
      ["publicApi"]
    ]
  },
  {
    "module": "component",
    "api": "ReactiveComponentModule",
    "kind": "ClassDeclaration",
    "signatures": ["class ReactiveComponentModule {}\n"],
    "information": []
  },
  {
    "module": "component-store",
    "api": "SelectConfig",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface SelectConfig {\n  debounce?: boolean;\n}\n"],
    "information": []
  },
  {
    "module": "component-store",
    "api": "initialStateToken",
    "kind": "VariableDeclaration",
    "signatures": ["const initialStateToken: InjectionToken<unknown>;\n"],
    "information": []
  },
  {
    "module": "component-store",
    "api": "ComponentStore",
    "kind": "ClassDeclaration",
    "signatures": [
      "class ComponentStore<T extends object> implements OnDestroy {\n  readonly destroy$ = this.destroySubject$.asObservable();\n  readonly state$: Observable<T> = this.select((s) => s);\n\n  ngOnDestroy();\n  updater<V>(\n    updaterFn: (state: T, value: V) => T\n  ): unknown extends V ? () => void : (t: V | Observable<V>) => Subscription;\n  setState(stateOrUpdaterFn: T | ((state: T) => T)): void;\n  select<\n    O extends Array<Observable<unknown> | SelectConfig | ProjectorFn>,\n    R,\n    ProjectorFn = (...a: unknown[]) => R\n  >(...args: O): Observable<R>;\n  effect<\n    ProvidedType = void,\n    OriginType extends Observable<ProvidedType> | unknown = Observable<\n      ProvidedType\n    >,\n    ObservableType = OriginType extends Observable<infer A> ? A : never,\n    ReturnType = ProvidedType | ObservableType extends void\n      ? () => void\n      : (\n          observableOrValue: ObservableType | Observable<ObservableType>\n        ) => Subscription\n  >(generator: (origin$: OriginType) => Observable<unknown>): ReturnType;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityActionFactory",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityActionFactory {\n  create<P = any>(\n    nameOrPayload: EntityActionPayload<P> | string,\n    entityOp?: EntityOp,\n    data?: P,\n    options?: EntityActionOptions\n  ): EntityAction<P>;\n  createFromAction<P = any>(\n    from: EntityAction,\n    newProperties: Partial<EntityActionPayload<P>>\n  ): EntityAction<P>;\n  formatActionType(op: string, tag: string);\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityActionGuard",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityActionGuard<T> {\n  mustBeEntity(action: EntityAction<T>): T;\n  mustBeEntities(action: EntityAction<T[]>): T[];\n  mustBeKey(action: EntityAction<string | number>): string | number | never;\n  mustBeKeys(action: EntityAction<(string | number)[]>): (string | number)[];\n  mustBeUpdate(action: EntityAction<Update<T>>): Update<T>;\n  mustBeUpdates(action: EntityAction<Update<T>[]>): Update<T>[];\n  mustBeUpdateResponse(\n    action: EntityAction<UpdateResponseData<T>>\n  ): UpdateResponseData<T>;\n  mustBeUpdateResponses(\n    action: EntityAction<UpdateResponseData<T>[]>\n  ): UpdateResponseData<T>[];\n}\n"
    ],
    "information": [
      [
        "info",
        "Guard methods that ensure EntityAction payload is as expected.",
        "Each method returns that payload if it passes the guard or",
        "throws an error."
      ]
    ]
  },
  {
    "module": "data",
    "api": "ofEntityOp",
    "kind": "FunctionDeclaration",
    "signatures": [
      "ofEntityOp<T extends EntityAction>( allowedOps: string[] | EntityOp[]\n): OperatorFunction<EntityAction, T>;",
      "ofEntityOp<T extends EntityAction>( ...allowedOps: (string | EntityOp)[]\n): OperatorFunction<EntityAction, T>;",
      "ofEntityOp<T extends EntityAction>( ...allowedEntityOps: any[]\n): OperatorFunction<EntityAction, T>;"
    ],
    "information": [
      [
        "info",
        "Select actions concerning one of the allowed Entity operations"
      ],
      [
        "param",
        "allowedEntityOps Entity operations (e.g, EntityOp.QUERY_ALL) whose actions should be selected",
        "Example:",
        "```",
        " this.actions.pipe(ofEntityOp(EntityOp.QUERY_ALL, EntityOp.QUERY_MANY), ...)",
        " this.actions.pipe(ofEntityOp(...queryOps), ...)",
        " this.actions.pipe(ofEntityOp(queryOps), ...)",
        " this.actions.pipe(ofEntityOp(), ...)",
        "```"
      ]
    ]
  },
  {
    "module": "data",
    "api": "ofEntityType",
    "kind": "FunctionDeclaration",
    "signatures": [
      "ofEntityType<T extends EntityAction>( allowedEntityNames?: string[]\n): OperatorFunction<EntityAction, T>;",
      "ofEntityType<T extends EntityAction>( ...allowedEntityNames: string[]\n): OperatorFunction<EntityAction, T>;",
      "ofEntityType<T extends EntityAction>( ...allowedEntityNames: any[]\n): OperatorFunction<EntityAction, T>;"
    ],
    "information": [
      ["info", "Select actions concerning one of the allowed Entity types"],
      [
        "param",
        "allowedEntityNames Entity-type names (e.g, 'Hero') whose actions should be selected",
        "Example:",
        "```",
        " this.actions.pipe(ofEntityType(), ...)",
        " this.actions.pipe(ofEntityType('Hero'), ...)",
        " this.actions.pipe(ofEntityType('Hero', 'Villain', 'Sidekick'), ...)",
        " this.actions.pipe(ofEntityType(...theChosen), ...)",
        " this.actions.pipe(ofEntityType(theChosen), ...)",
        "```"
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityAction",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityAction<P = any> {\n  readonly type: string;\n  readonly payload: EntityActionPayload<P>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityActionOptions",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityActionOptions {\n  readonly correlationId?: any;\n  readonly isOptimistic?: boolean;\n  readonly mergeStrategy?: MergeStrategy;\n  readonly tag?: string;\n  error?: Error;\n  skip?: boolean;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityActionPayload",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityActionPayload<P = any> {\n  readonly entityName: string;\n  readonly entityOp: EntityOp;\n  readonly data?: P;\n\n  // inherited from EntityActionOptions\n  readonly correlationId?: any;\n  readonly isOptimistic?: boolean;\n  readonly mergeStrategy?: MergeStrategy;\n  readonly tag?: string;\n  error?: Error;\n  skip?: boolean;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCacheAction",
    "kind": "EnumDeclaration",
    "signatures": [
      "export enum EntityCacheAction {\n  CLEAR_COLLECTIONS = '@ngrx/data/entity-cache/clear-collections',\n  LOAD_COLLECTIONS = '@ngrx/data/entity-cache/load-collections',\n  MERGE_QUERY_SET = '@ngrx/data/entity-cache/merge-query-set',\n  SET_ENTITY_CACHE = '@ngrx/data/entity-cache/set-cache',\n\n  SAVE_ENTITIES = '@ngrx/data/entity-cache/save-entities',\n  SAVE_ENTITIES_CANCEL = '@ngrx/data/entity-cache/save-entities-cancel',\n  SAVE_ENTITIES_CANCELED = '@ngrx/data/entity-cache/save-entities-canceled',\n  SAVE_ENTITIES_ERROR = '@ngrx/data/entity-cache/save-entities-error',\n  SAVE_ENTITIES_SUCCESS = '@ngrx/data/entity-cache/save-entities-success',\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCacheQuerySet",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface EntityCacheQuerySet {}\n"],
    "information": [
      [
        "info",
        "Hash of entities keyed by EntityCollection name,",
        "typically the result of a query that returned results from a multi-collection query",
        "that will be merged into an EntityCache via the `MergeQuerySet` action."
      ]
    ]
  },
  {
    "module": "data",
    "api": "ClearCollections",
    "kind": "ClassDeclaration",
    "signatures": [
      "class ClearCollections implements Action {\n  readonly payload: { collections?: string[]; tag?: string };\n  readonly type = EntityCacheAction.CLEAR_COLLECTIONS;\n}\n"
    ],
    "information": [
      ["info", "Clear the collections identified in the collectionSet."],
      [
        "param",
        "[collections] Array of names of the collections to clear.",
        "If empty array, does nothing. If no array, clear all collections."
      ],
      [
        "param",
        "[tag] Optional tag to identify the operation from the app perspective."
      ]
    ]
  },
  {
    "module": "data",
    "api": "LoadCollections",
    "kind": "ClassDeclaration",
    "signatures": [
      "class LoadCollections implements Action {\n  readonly payload: { collections: EntityCacheQuerySet; tag?: string };\n  readonly type = EntityCacheAction.LOAD_COLLECTIONS;\n}\n"
    ],
    "information": [
      [
        "info",
        "Create entity cache action that loads multiple entity collections at the same time.",
        "before any selectors$ observables emit."
      ],
      [
        "param",
        "querySet The collections to load, typically the result of a query."
      ],
      [
        "param",
        "[tag] Optional tag to identify the operation from the app perspective.",
        "in the form of a map of entity collections."
      ]
    ]
  },
  {
    "module": "data",
    "api": "MergeQuerySet",
    "kind": "ClassDeclaration",
    "signatures": [
      "class MergeQuerySet implements Action {\n  readonly payload: {\n    querySet: EntityCacheQuerySet;\n    mergeStrategy?: MergeStrategy;\n    tag?: string;\n  };\n  readonly type = EntityCacheAction.MERGE_QUERY_SET;\n}\n"
    ],
    "information": [
      [
        "info",
        "Create entity cache action that merges entities from a query result",
        "that returned entities from multiple collections.",
        "Corresponding entity cache reducer should add and update all collections",
        "at the same time, before any selectors$ observables emit."
      ],
      [
        "param",
        "querySet The result of the query in the form of a map of entity collections.",
        "These are the entity data to merge into the respective collections."
      ],
      [
        "param",
        "mergeStrategy How to merge a queried entity when it is already in the collection.",
        "The default is MergeStrategy.PreserveChanges"
      ],
      [
        "param",
        "[tag] Optional tag to identify the operation from the app perspective."
      ]
    ]
  },
  {
    "module": "data",
    "api": "SetEntityCache",
    "kind": "ClassDeclaration",
    "signatures": [
      "class SetEntityCache implements Action {\n  readonly payload: { cache: EntityCache; tag?: string };\n  readonly type = EntityCacheAction.SET_ENTITY_CACHE;\n}\n"
    ],
    "information": [
      [
        "info",
        "Create entity cache action for replacing the entire entity cache.",
        "Dangerous because brute force but useful as when re-hydrating an EntityCache",
        "from local browser storage when the application launches."
      ],
      ["param", "cache New state of the entity cache"],
      [
        "param",
        "[tag] Optional tag to identify the operation from the app perspective."
      ]
    ]
  },
  {
    "module": "data",
    "api": "SaveEntities",
    "kind": "ClassDeclaration",
    "signatures": [
      "class SaveEntities implements Action {\n  readonly payload: {\n    readonly changeSet: ChangeSet;\n    readonly url: string;\n    readonly correlationId?: any;\n    readonly isOptimistic?: boolean;\n    readonly mergeStrategy?: MergeStrategy;\n    readonly tag?: string;\n    error?: Error;\n    skip?: boolean;\n  };\n  readonly type = EntityCacheAction.SAVE_ENTITIES;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "SaveEntitiesCancel",
    "kind": "ClassDeclaration",
    "signatures": [
      "class SaveEntitiesCancel implements Action {\n  readonly payload: {\n    readonly correlationId: any;\n    readonly reason?: string;\n    readonly entityNames?: string[];\n    readonly tag?: string;\n  };\n  readonly type = EntityCacheAction.SAVE_ENTITIES_CANCEL;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "SaveEntitiesCanceled",
    "kind": "ClassDeclaration",
    "signatures": [
      "class SaveEntitiesCanceled implements Action {\n  readonly payload: {\n    readonly correlationId: any;\n    readonly reason?: string;\n    readonly tag?: string;\n  };\n  readonly type = EntityCacheAction.SAVE_ENTITIES_CANCEL;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "SaveEntitiesError",
    "kind": "ClassDeclaration",
    "signatures": [
      "class SaveEntitiesError {\n  readonly payload: {\n    readonly error: DataServiceError;\n    readonly originalAction: SaveEntities;\n    readonly correlationId: any;\n  };\n  readonly type = EntityCacheAction.SAVE_ENTITIES_ERROR;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "SaveEntitiesSuccess",
    "kind": "ClassDeclaration",
    "signatures": [
      "class SaveEntitiesSuccess implements Action {\n  readonly payload: {\n    readonly changeSet: ChangeSet;\n    readonly url: string;\n    readonly correlationId?: any;\n    readonly isOptimistic?: boolean;\n    readonly mergeStrategy?: MergeStrategy;\n    readonly tag?: string;\n    error?: Error;\n    skip?: boolean;\n  };\n  readonly type = EntityCacheAction.SAVE_ENTITIES_SUCCESS;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "ChangeSetOperation",
    "kind": "EnumDeclaration",
    "signatures": [
      "export enum ChangeSetOperation {\n  Add = 'Add',\n  Delete = 'Delete',\n  Update = 'Update',\n  Upsert = 'Upsert',\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "ChangeSetAdd",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface ChangeSetAdd<T = any> {\n  op: ChangeSetOperation.Add;\n  entityName: string;\n  entities: T[];\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "ChangeSetDelete",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface ChangeSetDelete {\n  op: ChangeSetOperation.Delete;\n  entityName: string;\n  entities: string[] | number[];\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "ChangeSetUpdate",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface ChangeSetUpdate<T = any> {\n  op: ChangeSetOperation.Update;\n  entityName: string;\n  entities: Update<T>[];\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "ChangeSetUpsert",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface ChangeSetUpsert<T = any> {\n  op: ChangeSetOperation.Upsert;\n  entityName: string;\n  entities: T[];\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "ChangeSetItem",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type ChangeSetItem =\n  | ChangeSetAdd\n  | ChangeSetDelete\n  | ChangeSetUpdate\n  | ChangeSetUpsert;\n"
    ],
    "information": [
      [
        "info",
        "A entities of a single entity type, which are changed in the same way by a ChangeSetOperation"
      ]
    ]
  },
  {
    "module": "data",
    "api": "ChangeSet",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface ChangeSet<T = any> {\n  changes: ChangeSetItem[];\n  extras?: T;\n  tag?: string;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "ChangeSetItemFactory",
    "kind": "ClassDeclaration",
    "signatures": [
      "class ChangeSetItemFactory {\n  add<T>(entityName: string, entities: T | T[]): ChangeSetAdd<T>;\n  delete(\n    entityName: string,\n    keys: number | number[] | string | string[]\n  ): ChangeSetDelete;\n  update<T extends { id: string | number }>(\n    entityName: string,\n    updates: Update<T> | Update<T>[]\n  ): ChangeSetUpdate<T>;\n  upsert<T>(entityName: string, entities: T | T[]): ChangeSetUpsert<T>;\n}\n"
    ],
    "information": [
      ["info", "Factory to create a ChangeSetItem for a ChangeSetOperation"]
    ]
  },
  {
    "module": "data",
    "api": "changeSetItemFactory",
    "kind": "VariableDeclaration",
    "signatures": ["const changeSetItemFactory: ChangeSetItemFactory;\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "excludeEmptyChangeSetItems",
    "kind": "FunctionDeclaration",
    "signatures": [
      "excludeEmptyChangeSetItems(changeSet: ChangeSet): ChangeSet;"
    ],
    "information": [
      [
        "info",
        "Return ChangeSet after filtering out null and empty ChangeSetItems."
      ],
      ["param", "changeSet ChangeSet with changes to filter"]
    ]
  },
  {
    "module": "data",
    "api": "EntityOp",
    "kind": "EnumDeclaration",
    "signatures": [
      "export enum EntityOp {\n  CANCEL_PERSIST = '@ngrx/data/cancel-persist',\n  CANCELED_PERSIST = '@ngrx/data/canceled-persist',\n\n  QUERY_ALL = '@ngrx/data/query-all',\n  QUERY_ALL_SUCCESS = '@ngrx/data/query-all/success',\n  QUERY_ALL_ERROR = '@ngrx/data/query-all/error',\n\n  QUERY_LOAD = '@ngrx/data/query-load',\n  QUERY_LOAD_SUCCESS = '@ngrx/data/query-load/success',\n  QUERY_LOAD_ERROR = '@ngrx/data/query-load/error',\n\n  QUERY_MANY = '@ngrx/data/query-many',\n  QUERY_MANY_SUCCESS = '@ngrx/data/query-many/success',\n  QUERY_MANY_ERROR = '@ngrx/data/query-many/error',\n\n  QUERY_BY_KEY = '@ngrx/data/query-by-key',\n  QUERY_BY_KEY_SUCCESS = '@ngrx/data/query-by-key/success',\n  QUERY_BY_KEY_ERROR = '@ngrx/data/query-by-key/error',\n\n  SAVE_ADD_MANY = '@ngrx/data/save/add-many',\n  SAVE_ADD_MANY_ERROR = '@ngrx/data/save/add-many/error',\n  SAVE_ADD_MANY_SUCCESS = '@ngrx/data/save/add-many/success',\n\n  SAVE_ADD_ONE = '@ngrx/data/save/add-one',\n  SAVE_ADD_ONE_ERROR = '@ngrx/data/save/add-one/error',\n  SAVE_ADD_ONE_SUCCESS = '@ngrx/data/save/add-one/success',\n\n  SAVE_DELETE_MANY = '@ngrx/data/save/delete-many',\n  SAVE_DELETE_MANY_SUCCESS = '@ngrx/data/save/delete-many/success',\n  SAVE_DELETE_MANY_ERROR = '@ngrx/data/save/delete-many/error',\n\n  SAVE_DELETE_ONE = '@ngrx/data/save/delete-one',\n  SAVE_DELETE_ONE_SUCCESS = '@ngrx/data/save/delete-one/success',\n  SAVE_DELETE_ONE_ERROR = '@ngrx/data/save/delete-one/error',\n\n  SAVE_UPDATE_MANY = '@ngrx/data/save/update-many',\n  SAVE_UPDATE_MANY_SUCCESS = '@ngrx/data/save/update-many/success',\n  SAVE_UPDATE_MANY_ERROR = '@ngrx/data/save/update-many/error',\n\n  SAVE_UPDATE_ONE = '@ngrx/data/save/update-one',\n  SAVE_UPDATE_ONE_SUCCESS = '@ngrx/data/save/update-one/success',\n  SAVE_UPDATE_ONE_ERROR = '@ngrx/data/save/update-one/error',\n\n  SAVE_UPSERT_MANY = '@ngrx/data/save/upsert-many',\n  SAVE_UPSERT_MANY_SUCCESS = '@ngrx/data/save/upsert-many/success',\n  SAVE_UPSERT_MANY_ERROR = '@ngrx/data/save/upsert-many/error',\n\n  SAVE_UPSERT_ONE = '@ngrx/data/save/upsert-one',\n  SAVE_UPSERT_ONE_SUCCESS = '@ngrx/data/save/upsert-one/success',\n  SAVE_UPSERT_ONE_ERROR = '@ngrx/data/save/upsert-one/error',\n\n  ADD_ALL = '@ngrx/data/add-all',\n  ADD_MANY = '@ngrx/data/add-many',\n  ADD_ONE = '@ngrx/data/add-one',\n  REMOVE_ALL = '@ngrx/data/remove-all',\n  REMOVE_MANY = '@ngrx/data/remove-many',\n  REMOVE_ONE = '@ngrx/data/remove-one',\n  UPDATE_MANY = '@ngrx/data/update-many',\n  UPDATE_ONE = '@ngrx/data/update-one',\n  UPSERT_MANY = '@ngrx/data/upsert-many',\n  UPSERT_ONE = '@ngrx/data/upsert-one',\n\n  COMMIT_ALL = '@ngrx/data/commit-all',\n  COMMIT_MANY = '@ngrx/data/commit-many',\n  COMMIT_ONE = '@ngrx/data/commit-one',\n  UNDO_ALL = '@ngrx/data/undo-all',\n  UNDO_MANY = '@ngrx/data/undo-many',\n  UNDO_ONE = '@ngrx/data/undo-one',\n\n  SET_CHANGE_STATE = '@ngrx/data/set-change-state',\n  SET_COLLECTION = '@ngrx/data/set-collection',\n  SET_FILTER = '@ngrx/data/set-filter',\n  SET_LOADED = '@ngrx/data/set-loaded',\n  SET_LOADING = '@ngrx/data/set-loading',\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "OP_SUCCESS",
    "kind": "VariableDeclaration",
    "signatures": ["const OP_SUCCESS: '/success';\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "OP_ERROR",
    "kind": "VariableDeclaration",
    "signatures": ["const OP_ERROR: '/error';\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "makeErrorOp",
    "kind": "FunctionDeclaration",
    "signatures": ["makeErrorOp(op: EntityOp): EntityOp;"],
    "information": []
  },
  {
    "module": "data",
    "api": "makeSuccessOp",
    "kind": "FunctionDeclaration",
    "signatures": ["makeSuccessOp(op: EntityOp): EntityOp;"],
    "information": []
  },
  {
    "module": "data",
    "api": "MergeStrategy",
    "kind": "EnumDeclaration",
    "signatures": [
      "export enum MergeStrategy {\n  /**\n   * Update the collection entities and ignore all change tracking for this operation.\n   * Each entity's `changeState` is untouched.\n   */\n  IgnoreChanges,\n  /**\n   * Updates current values for unchanged entities.\n   * For each changed entity it preserves the current value and overwrites the `originalValue` with the merge entity.\n   * This is the query-success default.\n   */\n  PreserveChanges,\n  /**\n   * Replace the current collection entities.\n   * For each merged entity it discards the `changeState` and sets the `changeType` to \"unchanged\".\n   * This is the save-success default.\n   */\n  OverwriteChanges,\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "UpdateResponseData",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface UpdateResponseData<T> {\n  id: number | string;\n  changes: Partial<T>;\n  changed?: boolean;\n}\n"
    ],
    "information": [
      [
        "info",
        "Data returned in an EntityAction from the EntityEffects for SAVE_UPDATE_ONE_SUCCESS.",
        "Effectively extends Update<T> with a 'changed' flag.",
        "The is true if the server sent back changes to the entity data after update.",
        "Such changes must be in the entity data in changes property.",
        "Default is false (server did not return entity data; assume it changed nothing).",
        "See EntityEffects."
      ]
    ]
  },
  {
    "module": "data",
    "api": "DataServiceError",
    "kind": "ClassDeclaration",
    "signatures": ["class DataServiceError {\n  message: string | null;\n}\n"],
    "information": [
      [
        "info",
        "Error from a DataService",
        "The source error either comes from a failed HTTP response or was thrown within the service."
      ],
      [
        "param",
        "error the HttpErrorResponse or the error thrown by the service"
      ],
      [
        "param",
        "requestData the HTTP request information such as the method and the url."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityActionDataServiceError",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityActionDataServiceError {\n  error: DataServiceError;\n  originalAction: EntityAction;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "DefaultDataServiceConfig",
    "kind": "ClassDeclaration",
    "signatures": [
      "class DefaultDataServiceConfig {\n  root?: string;\n  entityHttpResourceUrls?: EntityHttpResourceUrls;\n  delete404OK?: boolean;\n  getDelay?: number;\n  saveDelay?: number;\n  timeout?: number;\n}\n"
    ],
    "information": [
      [
        "info",
        "Optional configuration settings for an entity collection data service",
        "such as the `DefaultDataService<T>`."
      ]
    ]
  },
  {
    "module": "data",
    "api": "DefaultDataService",
    "kind": "ClassDeclaration",
    "signatures": [
      "class DefaultDataService<T> implements EntityCollectionDataService<T> {\n  add(entity: T): Observable<T>;\n  delete(key: number | string): Observable<number | string>;\n  getAll(): Observable<T[]>;\n  getById(key: number | string): Observable<T>;\n  getWithQuery(queryParams: QueryParams | string): Observable<T[]>;\n  update(update: Update<T>): Observable<T>;\n  upsert(entity: T): Observable<T>;\n}\n"
    ],
    "information": [
      [
        "info",
        "A basic, generic entity data service",
        "suitable for persistence of most entities.",
        "Assumes a common REST-y web API"
      ]
    ]
  },
  {
    "module": "data",
    "api": "DefaultDataServiceFactory",
    "kind": "ClassDeclaration",
    "signatures": [
      "class DefaultDataServiceFactory {\n  create<T>(entityName: string): EntityCollectionDataService<T>;\n}\n"
    ],
    "information": [
      [
        "info",
        "Create a basic, generic entity data service",
        "suitable for persistence of most entities.",
        "Assumes a common REST-y web API"
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityCacheDataService",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCacheDataService {\n  saveEntities(changeSet: ChangeSet, url: string): Observable<ChangeSet>;\n}\n"
    ],
    "information": [
      [
        "info",
        "Default data service for making remote service calls targeting the entire EntityCache.",
        "See EntityDataService for services that target a single EntityCollection"
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityDataService",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityDataService {\n  getService<T>(entityName: string): EntityCollectionDataService<T>;\n  registerService<T>(\n    entityName: string,\n    service: EntityCollectionDataService<T>\n  );\n  registerServices(services: {\n    [name: string]: EntityCollectionDataService<any>;\n  });\n}\n"
    ],
    "information": [
      [
        "info",
        "Registry of EntityCollection data services that make REST-like CRUD calls",
        "to entity collection endpoints."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityHttpResourceUrls",
    "kind": "ClassDeclaration",
    "signatures": ["class EntityHttpResourceUrls {}\n"],
    "information": [
      [
        "info",
        "Known resource URLS for specific entity types.",
        "Each entity's resource URLS are endpoints that",
        "target single entity and multi-entity HTTP operations.",
        "Used by the `DefaultHttpUrlGenerator`."
      ]
    ]
  },
  {
    "module": "data",
    "api": "HttpResourceUrls",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface HttpResourceUrls {\n  entityResourceUrl: string;\n  collectionResourceUrl: string;\n}\n"
    ],
    "information": [
      [
        "info",
        "Resource URLS for HTTP operations that target single entity",
        "and multi-entity endpoints."
      ]
    ]
  },
  {
    "module": "data",
    "api": "HttpUrlGenerator",
    "kind": "ClassDeclaration",
    "signatures": [
      "class HttpUrlGenerator {\n  abstract entityResource(entityName: string, root: string): string;\n  abstract collectionResource(entityName: string, root: string): string;\n  abstract registerHttpResourceUrls(\n    entityHttpResourceUrls?: EntityHttpResourceUrls\n  ): void;\n}\n"
    ],
    "information": [
      [
        "info",
        "Generate the base part of an HTTP URL for",
        "single entity or entity collection resource"
      ]
    ]
  },
  {
    "module": "data",
    "api": "DefaultHttpUrlGenerator",
    "kind": "ClassDeclaration",
    "signatures": [
      "class DefaultHttpUrlGenerator implements HttpUrlGenerator {\n  entityResource(entityName: string, root: string): string;\n  collectionResource(entityName: string, root: string): string;\n  registerHttpResourceUrls(\n    entityHttpResourceUrls: EntityHttpResourceUrls\n  ): void;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "normalizeRoot",
    "kind": "FunctionDeclaration",
    "signatures": ["normalizeRoot(root: string);"],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCollectionDataService",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityCollectionDataService<T> {\n  readonly name: string;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "HttpMethods",
    "kind": "TypeAliasDeclaration",
    "signatures": ["type HttpMethods = 'DELETE' | 'GET' | 'POST' | 'PUT';\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "RequestData",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface RequestData {\n  method: HttpMethods;\n  url: string;\n  data?: any;\n  options?: any;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "QueryParams",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface QueryParams {}\n"],
    "information": [
      [
        "info",
        "A key/value map of parameters to be turned into an HTTP query string",
        "Same as HttpClient's HttpParamsOptions which is NOT exported at package level",
        "https:"
      ]
    ]
  },
  {
    "module": "data",
    "api": "PersistenceResultHandler",
    "kind": "ClassDeclaration",
    "signatures": [
      "class PersistenceResultHandler {\n  abstract handleSuccess(originalAction: EntityAction): (data: any) => Action;\n  abstract handleError(\n    originalAction: EntityAction\n  ): (\n    error: DataServiceError | Error\n  ) => EntityAction<EntityActionDataServiceError>;\n}\n"
    ],
    "information": [
      ["info", "Handling of responses from persistence operation"]
    ]
  },
  {
    "module": "data",
    "api": "DefaultPersistenceResultHandler",
    "kind": "ClassDeclaration",
    "signatures": [
      "class DefaultPersistenceResultHandler implements PersistenceResultHandler {\n  handleSuccess(originalAction: EntityAction): (data: any) => Action;\n  handleError(\n    originalAction: EntityAction\n  ): (\n    error: DataServiceError | Error\n  ) => EntityAction<EntityActionDataServiceError>;\n}\n"
    ],
    "information": [
      [
        "info",
        "Default handling of responses from persistence operation,",
        "specifically an EntityDataService"
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityCacheDispatcher",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCacheDispatcher {\n  reducedActions$: Observable<Action>;\n\n  dispatch(action: Action): Action;\n  cancelSaveEntities(\n    correlationId: any,\n    reason?: string,\n    entityNames?: string[],\n    tag?: string\n  ): void;\n  clearCollections(collections?: string[], tag?: string);\n  loadCollections(collections: EntityCacheQuerySet, tag?: string);\n  mergeQuerySet(\n    querySet: EntityCacheQuerySet,\n    mergeStrategy?: MergeStrategy,\n    tag?: string\n  );\n  setEntityCache(cache: EntityCache, tag?: string);\n  saveEntities(\n    changes: ChangeSetItem[] | ChangeSet,\n    url: string,\n    options?: EntityActionOptions\n  ): Observable<ChangeSet>;\n}\n"
    ],
    "information": [
      ["info", "Dispatches Entity Cache actions to the EntityCache reducer"]
    ]
  },
  {
    "module": "data",
    "api": "EntityServerCommands",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface EntityServerCommands<T> {}\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCacheCommands",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface EntityCacheCommands<T> {}\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCommands",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityCommands<T> {\n  // inherited from EntityServerCommands\n  // inherited from EntityCacheCommands\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityDispatcherBase",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityDispatcherBase<T> implements EntityDispatcher<T> {\n  guard: EntityActionGuard<T>;\n  toUpdate: (entity: Partial<T>) => Update<T>;\n\n  createEntityAction<P = any>(\n    entityOp: EntityOp,\n    data?: P,\n    options?: EntityActionOptions\n  ): EntityAction<P>;\n  createAndDispatch<P = any>(\n    op: EntityOp,\n    data?: P,\n    options?: EntityActionOptions\n  ): EntityAction<P>;\n  dispatch(action: Action): Action;\n  add(entity: T, options?: EntityActionOptions): Observable<T>;\n  cancel(\n    correlationId: any,\n    reason?: string,\n    options?: EntityActionOptions\n  ): void;\n  delete(\n    arg: number | string | T,\n    options?: EntityActionOptions\n  ): Observable<number | string>;\n  getAll(options?: EntityActionOptions): Observable<T[]>;\n  getByKey(key: any, options?: EntityActionOptions): Observable<T>;\n  getWithQuery(\n    queryParams: QueryParams | string,\n    options?: EntityActionOptions\n  ): Observable<T[]>;\n  load(options?: EntityActionOptions): Observable<T[]>;\n  update(entity: Partial<T>, options?: EntityActionOptions): Observable<T>;\n  upsert(entity: T, options?: EntityActionOptions): Observable<T>;\n  addAllToCache(entities: T[], options?: EntityActionOptions): void;\n  addOneToCache(entity: T, options?: EntityActionOptions): void;\n  addManyToCache(entities: T[], options?: EntityActionOptions): void;\n  clearCache(options?: EntityActionOptions): void;\n  removeOneFromCache(\n    arg: (number | string) | T,\n    options?: EntityActionOptions\n  ): void;\n  removeManyFromCache(\n    args: (number | string)[] | T[],\n    options?: EntityActionOptions\n  ): void;\n  updateOneInCache(entity: Partial<T>, options?: EntityActionOptions): void;\n  updateManyInCache(\n    entities: Partial<T>[],\n    options?: EntityActionOptions\n  ): void;\n  upsertOneInCache(entity: Partial<T>, options?: EntityActionOptions): void;\n  upsertManyInCache(\n    entities: Partial<T>[],\n    options?: EntityActionOptions\n  ): void;\n  setFilter(pattern: any): void;\n  setLoaded(isLoaded: boolean): void;\n  setLoading(isLoading: boolean): void;\n}\n"
    ],
    "information": [
      [
        "info",
        "Dispatches EntityCollection actions to their reducers and effects (default implementation).",
        "All save commands rely on an Ngrx Effect such as `EntityEffects.persist$`."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityDispatcherDefaultOptions",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityDispatcherDefaultOptions {\n  optimisticAdd = false;\n  optimisticDelete = true;\n  optimisticUpdate = false;\n  optimisticUpsert = false;\n  optimisticSaveEntities = false;\n}\n"
    ],
    "information": [
      [
        "info",
        "Default options for EntityDispatcher behavior",
        "such as whether `add()` is optimistic or pessimistic by default.",
        "An optimistic save modifies the collection immediately and before saving to the server.",
        "A pessimistic save modifies the collection after the server confirms the save was successful.",
        "This class initializes the defaults to the safest values.",
        "Provide an alternative to change the defaults for all entity collections."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityDispatcherFactory",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityDispatcherFactory implements OnDestroy {\n  reducedActions$: Observable<Action>;\n\n  create<T>(\n    /** Name of the entity type */\n    entityName: string,\n    /**\n     * Function that returns the primary key for an entity `T`.\n     * Usually acquired from `EntityDefinition` metadata.\n     */\n    selectId: IdSelector<T> = defaultSelectId,\n    /** Defaults for options that influence dispatcher behavior such as whether\n     * `add()` is optimistic or pessimistic;\n     */\n    defaultOptions: Partial<EntityDispatcherDefaultOptions> = {}\n  ): EntityDispatcher<T>;\n  ngOnDestroy();\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityDispatcher",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityDispatcher<T> {\n  readonly entityName: string;\n  readonly guard: EntityActionGuard<T>;\n  readonly selectId: IdSelector<T>;\n  readonly store: Store<EntityCache>;\n\n  // inherited from EntityCommands\n}\n"
    ],
    "information": [
      [
        "info",
        "Dispatches EntityCollection actions to their reducers and effects.",
        "The substance of the interface is in EntityCommands."
      ]
    ]
  },
  {
    "module": "data",
    "api": "PersistanceCanceled",
    "kind": "ClassDeclaration",
    "signatures": ["class PersistanceCanceled {}\n"],
    "information": [["info", "Persistence operation canceled"]]
  },
  {
    "module": "data",
    "api": "EntityCacheEffects",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCacheEffects {\n  saveEntitiesCancel$: Observable<SaveEntitiesCancel> = createEffect(\n    () =>\n      this.actions.pipe(\n        ofType(EntityCacheAction.SAVE_ENTITIES_CANCEL),\n        filter((a: SaveEntitiesCancel) => a.payload.correlationId != null)\n      ),\n    { dispatch: false }\n  );\n  saveEntities$: Observable<Action> = createEffect(() =>\n    this.actions.pipe(\n      ofType(EntityCacheAction.SAVE_ENTITIES),\n      mergeMap((action: SaveEntities) => this.saveEntities(action))\n    )\n  );\n\n  saveEntities(action: SaveEntities): Observable<Action>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "persistOps",
    "kind": "VariableDeclaration",
    "signatures": ["const persistOps: EntityOp[];\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityEffects",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityEffects {\n  cancel$: Observable<any> = createEffect(\n    () =>\n      this.actions.pipe(\n        ofEntityOp(EntityOp.CANCEL_PERSIST),\n        map((action: EntityAction) => action.payload.correlationId),\n        filter((id) => id != null)\n      ),\n    { dispatch: false }\n  );\n  persist$: Observable<Action> = createEffect(() =>\n    this.actions.pipe(\n      ofEntityOp(persistOps),\n      mergeMap((action) => this.persist(action))\n    )\n  );\n\n  persist(action: EntityAction): Observable<Action>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityDefinitions",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface EntityDefinitions {}\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityDefinitionService",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityDefinitionService {\n  getDefinition<T>(entityName: string, shouldThrow = true): EntityDefinition<T>;\n  registerMetadata(metadata: EntityMetadata);\n  registerMetadataMap(metadataMap: EntityMetadataMap = {});\n  registerDefinition<T>(definition: EntityDefinition<T>);\n  registerDefinitions(definitions: EntityDefinitions);\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityDefinition",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityDefinition<T = any> {\n  entityName: string;\n  entityAdapter: EntityAdapter<T>;\n  entityDispatcherOptions?: Partial<EntityDispatcherDefaultOptions>;\n  initialState: EntityCollection<T>;\n  metadata: EntityMetadata<T>;\n  noChangeTracking: boolean;\n  selectId: IdSelector<T>;\n  sortComparer: false | Comparer<T>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "createEntityDefinition",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createEntityDefinition<T, S extends object>( metadata: EntityMetadata<T, S>\n): EntityDefinition<T>;"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityFilterFn",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type EntityFilterFn<T> = (entities: T[], pattern?: any) => T[];\n"
    ],
    "information": [
      [
        "info",
        "Filters the `entities` array argument and returns the original `entities`,",
        "or a new filtered array of entities.",
        "NEVER mutate the original `entities` array itself.",
        "/"
      ]
    ]
  },
  {
    "module": "data",
    "api": "PropsFilterFnFactory",
    "kind": "FunctionDeclaration",
    "signatures": [
      "PropsFilterFnFactory<T = any>( props: (keyof T)[] = []\n): EntityFilterFn<T>;"
    ],
    "information": [
      [
        "info",
        "Creates an {EntityFilterFn} that matches RegExp or RegExp string pattern",
        "anywhere in any of the given props of an entity.",
        "If pattern is a string, spaces are significant and ignores case."
      ]
    ]
  },
  {
    "module": "data",
    "api": "ENTITY_METADATA_TOKEN",
    "kind": "VariableDeclaration",
    "signatures": [
      "const ENTITY_METADATA_TOKEN: InjectionToken<EntityMetadataMap>;\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityMetadata",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityMetadata<T = any, S extends object = {}> {\n  entityName: string;\n  entityDispatcherOptions?: Partial<EntityDispatcherDefaultOptions>;\n  filterFn?: EntityFilterFn<T>;\n  noChangeTracking?: boolean;\n  selectId?: IdSelector<T>;\n  sortComparer?: false | Comparer<T>;\n  additionalCollectionState?: S;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityMetadataMap",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface EntityMetadataMap {}\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCollectionServiceBase",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCollectionServiceBase<\n  T,\n  S$ extends EntitySelectors$<T> = EntitySelectors$<T>\n> implements EntityCollectionService<T> {\n  readonly dispatcher: EntityDispatcher<T>;\n  readonly selectors: EntitySelectors<T>;\n  readonly selectors$: S$;\n  guard: EntityActionGuard<T>;\n  selectId: IdSelector<T>;\n  toUpdate: (entity: Partial<T>) => Update<T>;\n  collection$: Observable<EntityCollection<T>> | Store<EntityCollection<T>>;\n  count$: Observable<number> | Store<number>;\n  entities$: Observable<T[]> | Store<T[]>;\n  entityActions$: Observable<EntityAction>;\n  entityMap$: Observable<Dictionary<T>> | Store<Dictionary<T>>;\n  errors$: Observable<EntityAction>;\n  filter$: Observable<any> | Store<any>;\n  filteredEntities$: Observable<T[]> | Store<T[]>;\n  keys$: Observable<string[] | number[]> | Store<string[] | number[]>;\n  loaded$: Observable<boolean> | Store<boolean>;\n  loading$: Observable<boolean> | Store<boolean>;\n  changeState$: Observable<ChangeStateMap<T>> | Store<ChangeStateMap<T>>;\n\n  createEntityAction<P = any>(\n    op: EntityOp,\n    data?: P,\n    options?: EntityActionOptions\n  ): EntityAction<P>;\n  createAndDispatch<P = any>(\n    op: EntityOp,\n    data?: P,\n    options?: EntityActionOptions\n  ): EntityAction<P>;\n  dispatch(action: Action): Action;\n  add(entity: T, options?: EntityActionOptions): Observable<T>;\n  cancel(\n    correlationId: any,\n    reason?: string,\n    options?: EntityActionOptions\n  ): void;\n  delete(\n    arg: number | string | T,\n    options?: EntityActionOptions\n  ): Observable<number | string>;\n  getAll(options?: EntityActionOptions): Observable<T[]>;\n  getByKey(key: any, options?: EntityActionOptions): Observable<T>;\n  getWithQuery(\n    queryParams: QueryParams | string,\n    options?: EntityActionOptions\n  ): Observable<T[]>;\n  load(options?: EntityActionOptions): Observable<T[]>;\n  update(entity: Partial<T>, options?: EntityActionOptions): Observable<T>;\n  upsert(entity: T, options?: EntityActionOptions): Observable<T>;\n  addAllToCache(entities: T[], options?: EntityActionOptions): void;\n  addOneToCache(entity: T, options?: EntityActionOptions): void;\n  addManyToCache(entities: T[], options?: EntityActionOptions): void;\n  clearCache(): void;\n  removeOneFromCache(\n    arg: (number | string) | T,\n    options?: EntityActionOptions\n  ): void;\n  removeManyFromCache(\n    args: (number | string)[] | T[],\n    options?: EntityActionOptions\n  ): void;\n  updateOneInCache(entity: Partial<T>, options?: EntityActionOptions): void;\n  updateManyInCache(\n    entities: Partial<T>[],\n    options?: EntityActionOptions\n  ): void;\n  upsertOneInCache(entity: Partial<T>, options?: EntityActionOptions): void;\n  upsertManyInCache(\n    entities: Partial<T>[],\n    options?: EntityActionOptions\n  ): void;\n  setFilter(pattern: any): void;\n  setLoaded(isLoaded: boolean): void;\n  setLoading(isLoading: boolean): void;\n}\n"
    ],
    "information": [
      [
        "info",
        "Base class for a concrete EntityCollectionService<T>.",
        "Can be instantiated. Cannot be injected. Use EntityCollectionServiceFactory to create."
      ],
      [
        "param",
        "EntityCollectionServiceElements The ingredients for this service",
        "as a source of supporting services for creating an EntityCollectionService<T> instance."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityCollectionServiceElements",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityCollectionServiceElements<\n  T,\n  S$ extends EntitySelectors$<T> = EntitySelectors$<T>\n> {\n  readonly dispatcher: EntityDispatcher<T>;\n  readonly entityName: string;\n  readonly selectors: EntitySelectors<T>;\n  readonly selectors$: S$;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCollectionServiceElementsFactory",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCollectionServiceElementsFactory {\n  create<T, S$ extends EntitySelectors$<T> = EntitySelectors$<T>>(\n    entityName: string\n  ): EntityCollectionServiceElements<T, S$>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCollectionServiceFactory",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCollectionServiceFactory {\n  create<T, S$ extends EntitySelectors$<T> = EntitySelectors$<T>>(\n    entityName: string\n  ): EntityCollectionService<T>;\n}\n"
    ],
    "information": [
      [
        "info",
        "Creates EntityCollectionService instances for",
        "a cached collection of T entities in the ngrx store."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityCollectionService",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityCollectionService<T> {\n  readonly dispatcher: EntityDispatcher<T>;\n  readonly entityName: string;\n  readonly selectors: EntitySelectors<T>;\n  readonly selectors$: EntitySelectors$<T>;\n\n  // inherited from EntityCommands\n\n  // inherited from EntitySelectors$\n  readonly entityName: string;\n  readonly collection$: Observable<EntityCollection> | Store<EntityCollection>;\n  readonly count$: Observable<number> | Store<number>;\n  readonly entities$: Observable<T[]> | Store<T[]>;\n  readonly entityActions$: Observable<EntityAction>;\n  readonly entityMap$: Observable<Dictionary<T>> | Store<Dictionary<T>>;\n  readonly errors$: Observable<EntityAction>;\n  readonly filter$: Observable<string> | Store<string>;\n  readonly filteredEntities$: Observable<T[]> | Store<T[]>;\n  readonly keys$: Observable<string[] | number[]> | Store<string[] | number[]>;\n  readonly loaded$: Observable<boolean> | Store<boolean>;\n  readonly loading$: Observable<boolean> | Store<boolean>;\n  readonly changeState$:\n    | Observable<ChangeStateMap<T>>\n    | Store<ChangeStateMap<T>>;\n}\n"
    ],
    "information": [
      [
        "info",
        "A facade for managing",
        "a cached collection of T entities in the ngrx store."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityServicesBase",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityServicesBase implements EntityServices {\n  dispatch(action: Action);\n  getEntityCollectionService<\n    T,\n    S$ extends EntitySelectors$<T> = EntitySelectors$<T>\n  >(entityName: string): EntityCollectionService<T>;\n  registerEntityCollectionService<T>(\n    service: EntityCollectionService<T>,\n    serviceName?: string\n  );\n  registerEntityCollectionServices(\n    entityCollectionServices:\n      | EntityCollectionServiceMap\n      | EntityCollectionService<any>[]\n  ): void;\n}\n"
    ],
    "information": [
      [
        "info",
        "Base/default class of a central registry of EntityCollectionServices for all entity types.",
        "Create your own subclass to add app-specific members for an improved developer experience."
      ],
      [
        "example",
        "export class EntityServices extends EntityServicesBase {",
        "  constructor(entityServicesElements: EntityServicesElements) {",
        "    super(entityServicesElements);",
        "  }",
        "",
        "",
        "  get companyService() {",
        "    return this.getEntityCollectionService<Model.Company>('Company') as CompanyService;",
        "  }",
        "",
        "  clearCompany(companyId: string) {",
        "    this.dispatch(new ClearCompanyAction(companyId));",
        "  }",
        "}"
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityServicesElements",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityServicesElements {\n  readonly entityActionErrors$: Observable<EntityAction>;\n  readonly entityCache$: Observable<EntityCache> | Store<EntityCache>;\n  readonly reducedActions$: Observable<Action>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityServices",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityServices {\n  abstract readonly entityActionErrors$: Observable<EntityAction>;\n  abstract readonly entityCache$: Observable<EntityCache> | Store<EntityCache>;\n  abstract readonly reducedActions$: Observable<Action>;\n\n  abstract dispatch(action: Action): void;\n  abstract getEntityCollectionService<T = any>(\n    entityName: string\n  ): EntityCollectionService<T>;\n  abstract registerEntityCollectionService<T>(\n    service: EntityCollectionService<T>\n  ): void;\n  abstract registerEntityCollectionServices(\n    entityCollectionServices: EntityCollectionService<any>[]\n  ): void;\n  abstract registerEntityCollectionServices(\n    entityCollectionServiceMap: EntityCollectionServiceMap\n  ): void;\n}\n"
    ],
    "information": [
      [
        "info",
        "Class-Interface for EntityCache and EntityCollection services.",
        "Serves as an Angular provider token for this service class.",
        "Includes a registry of EntityCollectionServices for all entity types.",
        "Creates a new default EntityCollectionService for any entity type not in the registry.",
        "Optionally register specialized EntityCollectionServices for individual types"
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityCollectionServiceMap",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface EntityCollectionServiceMap {}\n"],
    "information": [
      [
        "info",
        "A map of service or entity names to their corresponding EntityCollectionServices."
      ]
    ]
  },
  {
    "module": "data",
    "api": "ENTITY_CACHE_NAME",
    "kind": "VariableDeclaration",
    "signatures": ["const ENTITY_CACHE_NAME: 'entityCache';\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "ENTITY_CACHE_NAME_TOKEN",
    "kind": "VariableDeclaration",
    "signatures": ["const ENTITY_CACHE_NAME_TOKEN: InjectionToken<string>;\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "ENTITY_CACHE_META_REDUCERS",
    "kind": "VariableDeclaration",
    "signatures": [
      "const ENTITY_CACHE_META_REDUCERS: InjectionToken<any[]>;\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "ENTITY_COLLECTION_META_REDUCERS",
    "kind": "VariableDeclaration",
    "signatures": [
      "const ENTITY_COLLECTION_META_REDUCERS: InjectionToken<any[]>;\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "INITIAL_ENTITY_CACHE_STATE",
    "kind": "VariableDeclaration",
    "signatures": [
      "const INITIAL_ENTITY_CACHE_STATE: InjectionToken<\n  EntityCache | (() => EntityCache)\n>;\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCacheReducerFactory",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCacheReducerFactory {\n  create(): ActionReducer<EntityCache, Action>;\n}\n"
    ],
    "information": [
      ["info", "Creates the EntityCacheReducer via its create() method"]
    ]
  },
  {
    "module": "data",
    "api": "EntityCache",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface EntityCache {}\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityChangeTrackerBase",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityChangeTrackerBase<T> implements EntityChangeTracker<T> {\n  commitAll(collection: EntityCollection<T>): EntityCollection<T>;\n  commitMany(\n    entityOrIdList: (number | string | T)[],\n    collection: EntityCollection<T>\n  ): EntityCollection<T>;\n  commitOne(\n    entityOrId: number | string | T,\n    collection: EntityCollection<T>\n  ): EntityCollection<T>;\n  mergeQueryResults(\n    entities: T[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  mergeSaveAdds(\n    entities: T[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  mergeSaveDeletes(\n    keys: (number | string)[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  mergeSaveUpdates(\n    updateResponseData: UpdateResponseData<T>[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy,\n    skipUnchanged = false\n  ): EntityCollection<T>;\n  mergeSaveUpserts(\n    entities: T[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  trackAddMany(\n    entities: T[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  trackAddOne(\n    entity: T,\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  trackDeleteMany(\n    keys: (number | string)[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  trackDeleteOne(\n    key: number | string,\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  trackUpdateMany(\n    updates: Update<T>[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  trackUpdateOne(\n    update: Update<T>,\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  trackUpsertMany(\n    entities: T[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  trackUpsertOne(\n    entity: T,\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T>;\n  undoAll(collection: EntityCollection<T>): EntityCollection<T>;\n  undoMany(\n    entityOrIdList: (number | string | T)[],\n    collection: EntityCollection<T>\n  ): EntityCollection<T>;\n  undoOne(\n    entityOrId: number | string | T,\n    collection: EntityCollection<T>\n  ): EntityCollection<T>;\n}\n"
    ],
    "information": [
      [
        "info",
        "The default implementation of EntityChangeTracker with",
        "methods for tracking, committing, and reverting/undoing unsaved entity changes.",
        "Used by EntityCollectionReducerMethods which should call tracker methods BEFORE modifying the collection.",
        "See EntityChangeTracker docs."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityChangeTracker",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface EntityChangeTracker<T> {}\n"],
    "information": [
      [
        "info",
        "Methods for tracking, committing, and reverting/undoing unsaved entity changes.",
        "Used by EntityCollectionReducerMethods which should call tracker methods BEFORE modifying the collection.",
        "See EntityChangeTracker docs."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityCollectionCreator",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCollectionCreator {\n  create<T = any, S extends EntityCollection<T> = EntityCollection<T>>(\n    entityName: string\n  ): S;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "createEmptyEntityCollection",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createEmptyEntityCollection<T>( entityName?: string\n): EntityCollection<T>;"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCollectionReducerMethodMap",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface EntityCollectionReducerMethodMap<T> {}\n"],
    "information": [
      [
        "info",
        "Map of {EntityOp} to reducer method for the operation.",
        "If an operation is missing, caller should return the collection for that reducer."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityCollectionReducerMethods",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCollectionReducerMethods<T> {\n  selectId: IdSelector<T>;\n  entityChangeTracker: EntityChangeTracker<T>;\n  readonly methods: EntityCollectionReducerMethodMap<T> = {\n    [EntityOp.CANCEL_PERSIST]: this.cancelPersist.bind(this),\n\n    [EntityOp.QUERY_ALL]: this.queryAll.bind(this),\n    [EntityOp.QUERY_ALL_ERROR]: this.queryAllError.bind(this),\n    [EntityOp.QUERY_ALL_SUCCESS]: this.queryAllSuccess.bind(this),\n\n    [EntityOp.QUERY_BY_KEY]: this.queryByKey.bind(this),\n    [EntityOp.QUERY_BY_KEY_ERROR]: this.queryByKeyError.bind(this),\n    [EntityOp.QUERY_BY_KEY_SUCCESS]: this.queryByKeySuccess.bind(this),\n\n    [EntityOp.QUERY_LOAD]: this.queryLoad.bind(this),\n    [EntityOp.QUERY_LOAD_ERROR]: this.queryLoadError.bind(this),\n    [EntityOp.QUERY_LOAD_SUCCESS]: this.queryLoadSuccess.bind(this),\n\n    [EntityOp.QUERY_MANY]: this.queryMany.bind(this),\n    [EntityOp.QUERY_MANY_ERROR]: this.queryManyError.bind(this),\n    [EntityOp.QUERY_MANY_SUCCESS]: this.queryManySuccess.bind(this),\n\n    [EntityOp.SAVE_ADD_MANY]: this.saveAddMany.bind(this),\n    [EntityOp.SAVE_ADD_MANY_ERROR]: this.saveAddManyError.bind(this),\n    [EntityOp.SAVE_ADD_MANY_SUCCESS]: this.saveAddManySuccess.bind(this),\n\n    [EntityOp.SAVE_ADD_ONE]: this.saveAddOne.bind(this),\n    [EntityOp.SAVE_ADD_ONE_ERROR]: this.saveAddOneError.bind(this),\n    [EntityOp.SAVE_ADD_ONE_SUCCESS]: this.saveAddOneSuccess.bind(this),\n\n    [EntityOp.SAVE_DELETE_MANY]: this.saveDeleteMany.bind(this),\n    [EntityOp.SAVE_DELETE_MANY_ERROR]: this.saveDeleteManyError.bind(this),\n    [EntityOp.SAVE_DELETE_MANY_SUCCESS]: this.saveDeleteManySuccess.bind(this),\n\n    [EntityOp.SAVE_DELETE_ONE]: this.saveDeleteOne.bind(this),\n    [EntityOp.SAVE_DELETE_ONE_ERROR]: this.saveDeleteOneError.bind(this),\n    [EntityOp.SAVE_DELETE_ONE_SUCCESS]: this.saveDeleteOneSuccess.bind(this),\n\n    [EntityOp.SAVE_UPDATE_MANY]: this.saveUpdateMany.bind(this),\n    [EntityOp.SAVE_UPDATE_MANY_ERROR]: this.saveUpdateManyError.bind(this),\n    [EntityOp.SAVE_UPDATE_MANY_SUCCESS]: this.saveUpdateManySuccess.bind(this),\n\n    [EntityOp.SAVE_UPDATE_ONE]: this.saveUpdateOne.bind(this),\n    [EntityOp.SAVE_UPDATE_ONE_ERROR]: this.saveUpdateOneError.bind(this),\n    [EntityOp.SAVE_UPDATE_ONE_SUCCESS]: this.saveUpdateOneSuccess.bind(this),\n\n    [EntityOp.SAVE_UPSERT_MANY]: this.saveUpsertMany.bind(this),\n    [EntityOp.SAVE_UPSERT_MANY_ERROR]: this.saveUpsertManyError.bind(this),\n    [EntityOp.SAVE_UPSERT_MANY_SUCCESS]: this.saveUpsertManySuccess.bind(this),\n\n    [EntityOp.SAVE_UPSERT_ONE]: this.saveUpsertOne.bind(this),\n    [EntityOp.SAVE_UPSERT_ONE_ERROR]: this.saveUpsertOneError.bind(this),\n    [EntityOp.SAVE_UPSERT_ONE_SUCCESS]: this.saveUpsertOneSuccess.bind(this),\n\n    [EntityOp.ADD_ALL]: this.addAll.bind(this),\n    [EntityOp.ADD_MANY]: this.addMany.bind(this),\n    [EntityOp.ADD_ONE]: this.addOne.bind(this),\n\n    [EntityOp.REMOVE_ALL]: this.removeAll.bind(this),\n    [EntityOp.REMOVE_MANY]: this.removeMany.bind(this),\n    [EntityOp.REMOVE_ONE]: this.removeOne.bind(this),\n\n    [EntityOp.UPDATE_MANY]: this.updateMany.bind(this),\n    [EntityOp.UPDATE_ONE]: this.updateOne.bind(this),\n\n    [EntityOp.UPSERT_MANY]: this.upsertMany.bind(this),\n    [EntityOp.UPSERT_ONE]: this.upsertOne.bind(this),\n\n    [EntityOp.COMMIT_ALL]: this.commitAll.bind(this),\n    [EntityOp.COMMIT_MANY]: this.commitMany.bind(this),\n    [EntityOp.COMMIT_ONE]: this.commitOne.bind(this),\n    [EntityOp.UNDO_ALL]: this.undoAll.bind(this),\n    [EntityOp.UNDO_MANY]: this.undoMany.bind(this),\n    [EntityOp.UNDO_ONE]: this.undoOne.bind(this),\n\n    [EntityOp.SET_CHANGE_STATE]: this.setChangeState.bind(this),\n    [EntityOp.SET_COLLECTION]: this.setCollection.bind(this),\n    [EntityOp.SET_FILTER]: this.setFilter.bind(this),\n    [EntityOp.SET_LOADED]: this.setLoaded.bind(this),\n    [EntityOp.SET_LOADING]: this.setLoading.bind(this),\n  };\n}\n"
    ],
    "information": [
      [
        "info",
        "Base implementation of reducer methods for an entity collection."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityCollectionReducerMethodsFactory",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCollectionReducerMethodsFactory {\n  create<T>(entityName: string): EntityCollectionReducerMethodMap<T>;\n}\n"
    ],
    "information": [
      [
        "info",
        "Creates {EntityCollectionReducerMethods} for a given entity type."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityCollectionReducers",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface EntityCollectionReducers {}\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCollectionReducerRegistry",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCollectionReducerRegistry {\n  getOrCreateReducer<T>(entityName: string): EntityCollectionReducer<T>;\n  registerReducer<T>(\n    entityName: string,\n    reducer: EntityCollectionReducer<T>\n  ): EntityCollectionReducer<T>;\n  registerReducers(reducers: EntityCollectionReducers);\n}\n"
    ],
    "information": [
      [
        "info",
        "Registry of entity types and their previously-constructed reducers.",
        "Can create a new CollectionReducer, which it registers for subsequent use."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityCollectionReducer",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type EntityCollectionReducer<T = any> = (\n  collection: EntityCollection<T>,\n  action: EntityAction\n) => EntityCollection<T>;\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCollectionReducerFactory",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityCollectionReducerFactory {\n  create<T = any>(entityName: string): EntityCollectionReducer<T>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "ChangeType",
    "kind": "EnumDeclaration",
    "signatures": [
      "export enum ChangeType {\n  /** The entity has not changed from its last known server state. */\n  Unchanged = 0,\n  /** The entity was added to the collection */\n  Added,\n  /** The entity is scheduled for delete and was removed from the collection */\n  Deleted,\n  /** The entity in the collection was updated */\n  Updated,\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "ChangeState",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface ChangeState<T> {\n  changeType: ChangeType;\n  originalValue?: T | undefined;\n}\n"
    ],
    "information": [
      [
        "info",
        "Change state for an entity with unsaved changes;",
        "an entry in an EntityCollection.changeState map"
      ]
    ]
  },
  {
    "module": "data",
    "api": "ChangeStateMap",
    "kind": "TypeAliasDeclaration",
    "signatures": ["type ChangeStateMap<T> = Dictionary<ChangeState<T>>;\n"],
    "information": [
      [
        "info",
        "Map of entity primary keys to entity ChangeStates.",
        "Each entry represents an entity with unsaved changes."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityCollection",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityCollection<T = any> {\n  entityName: string;\n  changeState: ChangeStateMap<T>;\n  filter?: string;\n  loaded: boolean;\n  loading: boolean;\n}\n"
    ],
    "information": [
      [
        "info",
        "Data and information about a collection of entities of a single type.",
        "EntityCollections are maintained in the EntityCache within the ngrx store."
      ]
    ]
  },
  {
    "module": "data",
    "api": "ENTITY_CACHE_SELECTOR_TOKEN",
    "kind": "VariableDeclaration",
    "signatures": ["const ENTITY_CACHE_SELECTOR_TOKEN: InjectionToken<any>;\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "entityCacheSelectorProvider",
    "kind": "VariableDeclaration",
    "signatures": ["const entityCacheSelectorProvider: FactoryProvider;\n"],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityCacheSelector",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type EntityCacheSelector = MemoizedSelector<Object, EntityCache>;\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "createEntityCacheSelector",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createEntityCacheSelector( entityCacheName?: string\n): MemoizedSelector<Object, EntityCache>;"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "CollectionSelectors",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface CollectionSelectors<T> {\n  readonly selectCount: Selector<EntityCollection<T>, number>;\n  readonly selectEntities: Selector<EntityCollection<T>, T[]>;\n  readonly selectEntityMap: Selector<EntityCollection<T>, Dictionary<T>>;\n  readonly selectFilter: Selector<EntityCollection<T>, string>;\n  readonly selectFilteredEntities: Selector<EntityCollection<T>, T[]>;\n  readonly selectKeys: Selector<EntityCollection<T>, string[] | number[]>;\n  readonly selectLoaded: Selector<EntityCollection<T>, boolean>;\n  readonly selectLoading: Selector<EntityCollection<T>, boolean>;\n  readonly selectChangeState: Selector<EntityCollection<T>, ChangeStateMap<T>>;\n}\n"
    ],
    "information": [
      [
        "info",
        "The selector functions for entity collection members,",
        "Selects from the entity collection to the collection member",
        "Contrast with {EntitySelectors}."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntitySelectors",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntitySelectors<T> {\n  readonly entityName: string;\n  readonly selectCollection: MemoizedSelector<Object, EntityCollection<T>>;\n  readonly selectCount: MemoizedSelector<Object, number>;\n  readonly selectEntities: MemoizedSelector<Object, T[]>;\n  readonly selectEntityCache: MemoizedSelector<Object, EntityCache>;\n  readonly selectEntityMap: MemoizedSelector<Object, Dictionary<T>>;\n  readonly selectFilter: MemoizedSelector<Object, string>;\n  readonly selectFilteredEntities: MemoizedSelector<Object, T[]>;\n  readonly selectKeys: MemoizedSelector<Object, string[] | number[]>;\n  readonly selectLoaded: MemoizedSelector<Object, boolean>;\n  readonly selectLoading: MemoizedSelector<Object, boolean>;\n  readonly selectChangeState: MemoizedSelector<Object, ChangeStateMap<T>>;\n}\n"
    ],
    "information": [
      [
        "info",
        "The selector functions for entity collection members,",
        "Selects from store root, through EntityCache, to the entity collection member",
        "Contrast with {CollectionSelectors}."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntitySelectorsFactory",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntitySelectorsFactory {\n  createCollectionSelector<\n    T = any,\n    C extends EntityCollection<T> = EntityCollection<T>\n  >(entityName: string);\n  createCollectionSelectors<\n    T,\n    S extends CollectionSelectors<T> = CollectionSelectors<T>\n  >(metadataOrName: EntityMetadata<T> | string): S;\n  create<T, S extends EntitySelectors<T> = EntitySelectors<T>>(\n    metadataOrName: EntityMetadata<T> | string\n  ): S;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntitySelectors$",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntitySelectors$<T> {\n  readonly entityName: string;\n  readonly collection$: Observable<EntityCollection> | Store<EntityCollection>;\n  readonly count$: Observable<number> | Store<number>;\n  readonly entities$: Observable<T[]> | Store<T[]>;\n  readonly entityActions$: Observable<EntityAction>;\n  readonly entityMap$: Observable<Dictionary<T>> | Store<Dictionary<T>>;\n  readonly errors$: Observable<EntityAction>;\n  readonly filter$: Observable<string> | Store<string>;\n  readonly filteredEntities$: Observable<T[]> | Store<T[]>;\n  readonly keys$: Observable<string[] | number[]> | Store<string[] | number[]>;\n  readonly loaded$: Observable<boolean> | Store<boolean>;\n  readonly loading$: Observable<boolean> | Store<boolean>;\n  readonly changeState$:\n    | Observable<ChangeStateMap<T>>\n    | Store<ChangeStateMap<T>>;\n}\n"
    ],
    "information": [
      [
        "info",
        "The selector observable functions for entity collection members."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntitySelectors$Factory",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntitySelectors$Factory {\n  entityCache$: Observable<EntityCache>;\n  entityActionErrors$: Observable<EntityAction>;\n\n  create<T, S$ extends EntitySelectors$<T> = EntitySelectors$<T>>(\n    entityName: string,\n    selectors: EntitySelectors<T>\n  ): S$;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "CorrelationIdGenerator",
    "kind": "ClassDeclaration",
    "signatures": ["class CorrelationIdGenerator {\n  next();\n}\n"],
    "information": [
      [
        "info",
        "Generates a string id beginning 'CRID',",
        "followed by a monotonically increasing integer for use as a correlation id.",
        "As they are produced locally by a singleton service,",
        "these ids are guaranteed to be unique only",
        "for the duration of a single client browser instance.",
        "Ngrx entity dispatcher query and save methods call this service to generate default correlation ids.",
        "Do NOT use for entity keys."
      ]
    ]
  },
  {
    "module": "data",
    "api": "DefaultLogger",
    "kind": "ClassDeclaration",
    "signatures": [
      "class DefaultLogger implements Logger {\n  error(message?: any, extra?: any);\n  log(message?: any, extra?: any);\n  warn(message?: any, extra?: any);\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "DefaultPluralizer",
    "kind": "ClassDeclaration",
    "signatures": [
      "class DefaultPluralizer {\n  pluralNames: EntityPluralNames = {};\n\n  pluralize(name: string);\n  registerPluralNames(pluralNames: EntityPluralNames): void;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "getGuid",
    "kind": "FunctionDeclaration",
    "signatures": ["getGuid();"],
    "information": []
  },
  {
    "module": "data",
    "api": "getGuidComb",
    "kind": "FunctionDeclaration",
    "signatures": ["getGuidComb(seed?: number);"],
    "information": [
      [
        "info",
        "Creates a sortable, pseudo-GUID (globally unique identifier)",
        "whose trailing 6 bytes (12 hex digits) are time-based",
        "Start either with the given getTime() value, seedTime,",
        "or get the current time in ms."
      ],
      ["param", "seed {number} - optional seed for reproducible time-part"]
    ]
  },
  {
    "module": "data",
    "api": "guidComparer",
    "kind": "FunctionDeclaration",
    "signatures": ["guidComparer(l: string, r: string);"],
    "information": []
  },
  {
    "module": "data",
    "api": "Logger",
    "kind": "ClassDeclaration",
    "signatures": [
      "class Logger {\n  abstract error(message?: any, ...optionalParams: any[]): void;\n  abstract log(message?: any, ...optionalParams: any[]): void;\n  abstract warn(message?: any, ...optionalParams: any[]): void;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityPluralNames",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface EntityPluralNames {}\n"],
    "information": [["info", "Mapping of entity type name to its plural"]]
  },
  {
    "module": "data",
    "api": "PLURAL_NAMES_TOKEN",
    "kind": "VariableDeclaration",
    "signatures": [
      "const PLURAL_NAMES_TOKEN: InjectionToken<EntityPluralNames>;\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "Pluralizer",
    "kind": "ClassDeclaration",
    "signatures": [
      "class Pluralizer {\n  abstract pluralize(name: string): string;\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "defaultSelectId",
    "kind": "FunctionDeclaration",
    "signatures": ["defaultSelectId(entity: any);"],
    "information": [
      [
        "info",
        "Default function that returns the entity's primary key (pkey).",
        "Assumes that the entity has an `id` pkey property.",
        "Returns `undefined` if no entity or `id`.",
        "Every selectId fn must return `undefined` when it cannot produce a full pkey."
      ]
    ]
  },
  {
    "module": "data",
    "api": "flattenArgs",
    "kind": "FunctionDeclaration",
    "signatures": ["flattenArgs<T>(args?: any[]): T[];"],
    "information": [
      [
        "info",
        "Flatten first arg if it is an array",
        "Allows fn with ...rest signature to be called with an array instead of spread",
        "Example:",
        "```",
        "",
        "const persistOps = [EntityOp.QUERY_ALL, EntityOp.ADD, ...];",
        "actions.pipe(ofEntityOp(...persistOps))",
        "actions.pipe(ofEntityOp(persistOps))",
        "```",
        "*/"
      ]
    ]
  },
  {
    "module": "data",
    "api": "toUpdateFactory",
    "kind": "FunctionDeclaration",
    "signatures": ["toUpdateFactory<T>(selectId?: IdSelector<T>);"],
    "information": [
      [
        "info",
        "Return a function that converts an entity (or partial entity) into the `Update<T>`",
        "whose `id` is the primary key and",
        "`changes` is the entity (or partial entity of changes)."
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityDataModuleConfig",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityDataModuleConfig {\n  entityMetadata?: EntityMetadataMap;\n  entityCacheMetaReducers?: (\n    | MetaReducer<EntityCache, Action>\n    | InjectionToken<MetaReducer<EntityCache, Action>>\n  )[];\n  entityCollectionMetaReducers?: MetaReducer<EntityCollection, EntityAction>[];\n  initialEntityCacheState?: EntityCache | (() => EntityCache);\n  pluralNames?: { [name: string]: string };\n}\n"
    ],
    "information": []
  },
  {
    "module": "data",
    "api": "EntityDataModuleWithoutEffects",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityDataModuleWithoutEffects implements OnDestroy {\n  static forRoot(\n    config: EntityDataModuleConfig\n  ): ModuleWithProviders<EntityDataModuleWithoutEffects>;\n  ngOnDestroy();\n}\n"
    ],
    "information": [
      [
        "info",
        "Module without effects or dataservices which means no HTTP calls",
        "This module helpful for internal testing.",
        "Also helpful for apps that handle server access on their own and",
        "therefore opt-out of @ngrx/effects for entities"
      ]
    ]
  },
  {
    "module": "data",
    "api": "EntityDataModule",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EntityDataModule {\n  static forRoot(\n    config: EntityDataModuleConfig\n  ): ModuleWithProviders<EntityDataModule>;\n  addEffects(effectSourceInstance: any);\n}\n"
    ],
    "information": [
      [
        "info",
        "entity-data main module includes effects and HTTP data services",
        "Configure with `forRoot`.",
        "No `forFeature` yet."
      ]
    ]
  },
  {
    "module": "effects",
    "api": "createEffect",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createEffect< C extends EffectConfig, DT extends DispatchType<C>, OT extends ObservableType<DT, OT>, R extends EffectResult<OT>\n>( source: () => R & ConditionallyDisallowActionCreator<DT, R>, config?: Partial<C>\n): R & CreateEffectMetadata;"
    ],
    "information": [
      [
        "description",
        "Creates an effect from an `Observable` and an `EffectConfig`."
      ],
      ["param", "source A function which returns an `Observable`."],
      [
        "param",
        "config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true."
      ],
      [
        "returns",
        "If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`."
      ],
      [
        "usageNotes",
        "",
        "** Mapping to a different action **",
        "```ts",
        "effectName$ = createEffect(",
        "  () => this.actions$.pipe(",
        "    ofType(FeatureActions.actionOne),",
        "    map(() => FeatureActions.actionTwo())",
        "  )",
        ");",
        "```",
        "",
        " ** Non-dispatching effects **",
        "```ts",
        "effectName$ = createEffect(",
        "  () => this.actions$.pipe(",
        "    ofType(FeatureActions.actionOne),",
        "    tap(() => console.log('Action One Dispatched'))",
        "  ),",
        "  { dispatch: false }",
        "",
        ");",
        "```"
      ]
    ]
  },
  {
    "module": "effects",
    "api": "EffectConfig",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EffectConfig {\n  dispatch?: boolean;\n  useEffectsErrorHandler?: boolean;\n}\n"
    ],
    "information": [["info", "Configures an effect created by `createEffect`."]]
  },
  {
    "module": "effects",
    "api": "Effect",
    "kind": "FunctionDeclaration",
    "signatures": ["Effect(config: EffectConfig = {});"],
    "information": []
  },
  {
    "module": "effects",
    "api": "getEffectsMetadata",
    "kind": "FunctionDeclaration",
    "signatures": ["getEffectsMetadata<T>(instance: T): EffectsMetadata<T>;"],
    "information": []
  },
  {
    "module": "effects",
    "api": "mergeEffects",
    "kind": "FunctionDeclaration",
    "signatures": [
      "mergeEffects( sourceInstance: any, globalErrorHandler: ErrorHandler, effectsErrorHandler: EffectsErrorHandler\n): Observable<EffectNotification>;"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "EffectsErrorHandler",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type EffectsErrorHandler = <T extends Action>(\n  observable$: Observable<T>,\n  errorHandler: ErrorHandler\n) => Observable<T>;\n"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "defaultEffectsErrorHandler",
    "kind": "FunctionDeclaration",
    "signatures": [
      "defaultEffectsErrorHandler<T extends Action>( observable$: Observable<T>, errorHandler: ErrorHandler, retryAttemptLeft: number = MAX_NUMBER_OF_RETRY_ATTEMPTS\n): Observable<T>;"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "EffectsMetadata",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type EffectsMetadata<T> = {\n  [key in EffectPropertyKey<T>]?: EffectConfig;\n};\n"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "CreateEffectMetadata",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface CreateEffectMetadata {\n  [CREATE_EFFECT_METADATA_KEY]: EffectConfig;\n}\n"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "Actions",
    "kind": "ClassDeclaration",
    "signatures": [
      "class Actions<V = Action> extends Observable<V> {\n  lift<R>(operator: Operator<V, R>): Observable<R>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "ofType",
    "kind": "FunctionDeclaration",
    "signatures": [
      "ofType< AC extends ActionCreator<string, Creator>[], U extends Action = Action, V = ReturnType<AC[number]>\n>(...allowedTypes: AC): OperatorFunction<U, V>;",
      "ofType< E extends Extract<U, { type: T1 }>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, U extends Action = Action, V = T1 extends string ? E : ReturnType<Extract<T1, AC>>\n>(t1: T1): OperatorFunction<U, V>;",
      "ofType< E extends Extract<U, { type: T1 | T2 }>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2, AC, E>\n>(t1: T1, t2: T2): OperatorFunction<U, V>;",
      "ofType< E extends Extract<U, { type: T1 | T2 | T3 }>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3, AC, E>\n>(t1: T1, t2: T2, t3: T3): OperatorFunction<U, V>;",
      "ofType< E extends Extract<U, { type: T1 | T2 | T3 | T4 }>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, T4 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3 | T4, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4): OperatorFunction<U, V>;",
      "ofType< E extends Extract<U, { type: T1 | T2 | T3 | T4 | T5 }>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, T4 extends string | AC, T5 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3 | T4 | T5, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): OperatorFunction<U, V>;",
      "ofType<V extends Action>( ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, V>;",
      "ofType( ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, Action>;"
    ],
    "information": [
      [
        "info",
        "'ofType' filters an Observable of Actions into an observable of the actions",
        "whose type strings are passed to it.",
        "",
        "For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and",
        "the type of the `Addition` action is `add`, then",
        "`actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.",
        "",
        "Properly typing this function is hard and requires some advanced TS tricks",
        "below.",
        "",
        "Type narrowing automatically works, as long as your `actions` object",
        "starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.",
        "",
        "For backwards compatibility, when one passes a single type argument",
        "`ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`",
        "completely overrides any possible inference from 'something'.",
        "",
        "Unfortunately, for unknown 'actions: Actions' these types will produce",
        "'Observable<never>'. In such cases one has to manually set the generic type",
        "like `actions.ofType<AdditionAction>('add')`."
      ]
    ]
  },
  {
    "module": "effects",
    "api": "EffectsModule",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EffectsModule {\n  static forFeature(\n    featureEffects: Type<any>[] = []\n  ): ModuleWithProviders<EffectsFeatureModule>;\n  static forRoot(\n    rootEffects: Type<any>[] = []\n  ): ModuleWithProviders<EffectsRootModule>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "EffectSources",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EffectSources extends Subject<any> {\n  addEffects(effectSourceInstance: any): void;\n  toActions(): Observable<Action>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "EffectsRunner",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EffectsRunner implements OnDestroy {\n  start();\n  ngOnDestroy();\n}\n"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "EffectNotification",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EffectNotification {\n  effect: Observable<any> | (() => Observable<any>);\n  propertyName: PropertyKey;\n  sourceName: string;\n  sourceInstance: any;\n  notification: Notification<Action | null | undefined>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "EffectsFeatureModule",
    "kind": "ClassDeclaration",
    "signatures": ["class EffectsFeatureModule {}\n"],
    "information": []
  },
  {
    "module": "effects",
    "api": "ROOT_EFFECTS_INIT",
    "kind": "VariableDeclaration",
    "signatures": ["const ROOT_EFFECTS_INIT: '@ngrx/effects/init';\n"],
    "information": []
  },
  {
    "module": "effects",
    "api": "rootEffectsInit",
    "kind": "VariableDeclaration",
    "signatures": ["const rootEffectsInit: any;\n"],
    "information": []
  },
  {
    "module": "effects",
    "api": "EffectsRootModule",
    "kind": "ClassDeclaration",
    "signatures": [
      "class EffectsRootModule {\n  addEffects(effectSourceInstance: any);\n}\n"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "EFFECTS_ERROR_HANDLER",
    "kind": "VariableDeclaration",
    "signatures": [
      "const EFFECTS_ERROR_HANDLER: InjectionToken<EffectsErrorHandler>;\n"
    ],
    "information": []
  },
  {
    "module": "effects",
    "api": "act",
    "kind": "FunctionDeclaration",
    "signatures": [
      "act< Input, OutputAction extends Action, ErrorAction extends Action\n>( project: (input: Input, index: number) => Observable<OutputAction>, error: (error: any, input: Input) => ErrorAction\n): (source: Observable<Input>) => Observable<OutputAction | ErrorAction>;",
      "act< Input, OutputAction extends Action, ErrorAction extends Action, CompleteAction extends Action = never, UnsubscribeAction extends Action = never\n>( config: ActConfig< Input, OutputAction, ErrorAction, CompleteAction, UnsubscribeAction >\n): ( source: Observable<Input>\n) => Observable< OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n>;",
      "act< Input, OutputAction extends Action, ErrorAction extends Action, CompleteAction extends Action = never, UnsubscribeAction extends Action = never\n>( /** Allow to take either config object or project/error functions */ configOrProject: | ActConfig< Input, OutputAction, ErrorAction, CompleteAction, UnsubscribeAction > | ((input: Input, index: number) => Observable<OutputAction>), errorFn?: (error: any, input: Input) => ErrorAction\n): ( source: Observable<Input>\n) => Observable< OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n>;"
    ],
    "information": [
      [
        "info",
        "Wraps project fn with error handling making it safe to use in Effects.",
        "Takes either config with named properties that represent different possible",
        "callbacks or project/error callbacks that are required."
      ]
    ]
  },
  {
    "module": "effects",
    "api": "OnIdentifyEffects",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface OnIdentifyEffects {}\n"],
    "information": [
      [
        "description",
        "Interface to set an identifier for effect instances.",
        "",
        "By default, each Effects class is registered",
        "once regardless of how many times the Effect class",
        "is loaded. By implementing this interface, you define",
        "a unique identifier to register an Effects class instance",
        "multiple times."
      ],
      [
        "usageNotes",
        "",
        "### Set an identifier for an Effects class",
        "",
        "```ts",
        "class EffectWithIdentifier implements OnIdentifyEffects {",
        " constructor(private effectIdentifier: string) {}",
        "",
        " ngrxOnIdentifyEffects() {",
        "   return this.effectIdentifier;",
        " }",
        "",
        "```"
      ]
    ]
  },
  {
    "module": "effects",
    "api": "OnRunEffects",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface OnRunEffects {}\n"],
    "information": [
      [
        "description",
        "Interface to control the lifecycle of effects.",
        "",
        "By default, effects are merged and subscribed to the store. Implement the OnRunEffects interface to control the lifecycle of the resolved effects."
      ],
      [
        "usageNotes",
        "",
        "### Implement the OnRunEffects interface on an Effects class",
        "",
        "```ts",
        "export class UserEffects implements OnRunEffects {",
        "  constructor(private actions$: Actions) {}",
        "",
        "  ngrxOnRunEffects(resolvedEffects$: Observable<EffectNotification>) {",
        "    return this.actions$.pipe(",
        "      ofType('LOGGED_IN'),",
        "      exhaustMap(() =>",
        "        resolvedEffects$.pipe(",
        "          takeUntil(this.actions$.pipe(ofType('LOGGED_OUT')))",
        "        )",
        "      )",
        "    );",
        "  }",
        "}",
        "```"
      ]
    ]
  },
  {
    "module": "effects",
    "api": "OnInitEffects",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface OnInitEffects {}\n"],
    "information": [
      [
        "description",
        "Interface to dispatch an action after effect registration.",
        "",
        "Implement this interface to dispatch a custom action after",
        "the effect has been added. You can listen to this action",
        "in the rest of the application to execute something after",
        "the effect is registered."
      ],
      [
        "usageNotes",
        "",
        "### Set an identifier for an Effects class",
        "",
        "```ts",
        "class EffectWithInitAction implements OnInitEffects {",
        " ngrxOnInitEffects() {",
        "   return { type: '[EffectWithInitAction] Init' };",
        " }",
        "```"
      ]
    ]
  },
  {
    "module": "effects",
    "api": "USER_PROVIDED_EFFECTS",
    "kind": "VariableDeclaration",
    "signatures": [
      "const USER_PROVIDED_EFFECTS: InjectionToken<Type<any>[][]>;\n"
    ],
    "information": []
  },
  {
    "module": "entity",
    "api": "createEntityAdapter",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createEntityAdapter<T>( options: { selectId?: IdSelector<T>; sortComparer?: false | Comparer<T>; } = {}\n): EntityAdapter<T>;"
    ],
    "information": []
  },
  {
    "module": "entity",
    "api": "Dictionary",
    "kind": "ClassDeclaration",
    "signatures": ["class Dictionary<T> implements DictionaryNum<T> {}\n"],
    "information": []
  },
  {
    "module": "entity",
    "api": "EntityState",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityState<T> {\n  ids: string[] | number[];\n  entities: Dictionary<T>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "entity",
    "api": "EntityAdapter",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface EntityAdapter<T> {\n  selectId: IdSelector<T>;\n  sortComparer: false | Comparer<T>;\n\n  // inherited from EntityStateAdapter\n}\n"
    ],
    "information": []
  },
  {
    "module": "entity",
    "api": "Update",
    "kind": "TypeAliasDeclaration",
    "signatures": ["type Update<T> = UpdateStr<T> | UpdateNum<T>;\n"],
    "information": []
  },
  {
    "module": "entity",
    "api": "EntityMap",
    "kind": "TypeAliasDeclaration",
    "signatures": ["type EntityMap<T> = (entity: T) => T;\n"],
    "information": []
  },
  {
    "module": "entity",
    "api": "EntityMapOne",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type EntityMapOne<T> = EntityMapOneNum<T> | EntityMapOneStr<T>;\n"
    ],
    "information": []
  },
  {
    "module": "entity",
    "api": "Predicate",
    "kind": "TypeAliasDeclaration",
    "signatures": ["type Predicate<T> = (entity: T) => boolean;\n"],
    "information": []
  },
  {
    "module": "entity",
    "api": "IdSelector",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type IdSelector<T> = IdSelectorStr<T> | IdSelectorNum<T>;\n"
    ],
    "information": []
  },
  {
    "module": "entity",
    "api": "Comparer",
    "kind": "TypeAliasDeclaration",
    "signatures": ["type Comparer<T> = (a: T, b: T) => number;\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "ROUTER_ERROR",
    "kind": "VariableDeclaration",
    "signatures": ["const ROUTER_ERROR: '@ngrx/router-store/error';\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "ROUTER_CANCEL",
    "kind": "VariableDeclaration",
    "signatures": ["const ROUTER_CANCEL: '@ngrx/router-store/cancel';\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "ROUTER_NAVIGATION",
    "kind": "VariableDeclaration",
    "signatures": [
      "const ROUTER_NAVIGATION: '@ngrx/router-store/navigation';\n"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "ROUTER_NAVIGATED",
    "kind": "VariableDeclaration",
    "signatures": ["const ROUTER_NAVIGATED: '@ngrx/router-store/navigated';\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "ROUTER_REQUEST",
    "kind": "VariableDeclaration",
    "signatures": ["const ROUTER_REQUEST: '@ngrx/router-store/request';\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "RouterAction",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterAction<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> =\n  | RouterRequestAction<V>\n  | RouterNavigationAction<V>\n  | RouterCancelAction<T, V>\n  | RouterErrorAction<T, V>\n  | RouterNavigatedAction<V>;\n"
    ],
    "information": [["info", "A union type of router actions."]]
  },
  {
    "module": "router-store",
    "api": "RouterCancelAction",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterCancelAction<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_CANCEL;\n  payload: RouterCancelPayload<T, V>;\n};\n"
    ],
    "information": [
      ["info", "An action dispatched when the router cancels navigation."]
    ]
  },
  {
    "module": "router-store",
    "api": "RouterCancelPayload",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterCancelPayload<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: V;\n  storeState: T;\n  event: NavigationCancel;\n};\n"
    ],
    "information": [["info", "Payload of ROUTER_CANCEL."]]
  },
  {
    "module": "router-store",
    "api": "RouterErrorAction",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterErrorAction<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_ERROR;\n  payload: RouterErrorPayload<T, V>;\n};\n"
    ],
    "information": [["info", "An action dispatched when the router errors."]]
  },
  {
    "module": "router-store",
    "api": "RouterErrorPayload",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterErrorPayload<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: V;\n  storeState: T;\n  event: NavigationError;\n};\n"
    ],
    "information": [["info", "Payload of ROUTER_ERROR."]]
  },
  {
    "module": "router-store",
    "api": "RouterNavigatedAction",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterNavigatedAction<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_NAVIGATED;\n  payload: RouterNavigatedPayload<T>;\n};\n"
    ],
    "information": [
      [
        "info",
        "An action dispatched after navigation has ended and new route is active."
      ]
    ]
  },
  {
    "module": "router-store",
    "api": "RouterNavigatedPayload",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterNavigatedPayload<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: T;\n  event: NavigationEnd;\n};\n"
    ],
    "information": [["info", "Payload of ROUTER_NAVIGATED."]]
  },
  {
    "module": "router-store",
    "api": "RouterNavigationAction",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterNavigationAction<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_NAVIGATION;\n  payload: RouterNavigationPayload<T>;\n};\n"
    ],
    "information": [["info", "An action dispatched when the router navigates."]]
  },
  {
    "module": "router-store",
    "api": "RouterNavigationPayload",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterNavigationPayload<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: T;\n  event: RoutesRecognized;\n};\n"
    ],
    "information": [["info", "Payload of ROUTER_NAVIGATION."]]
  },
  {
    "module": "router-store",
    "api": "RouterRequestAction",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterRequestAction<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_REQUEST;\n  payload: RouterRequestPayload<T>;\n};\n"
    ],
    "information": [
      [
        "info",
        "An action dispatched when a router navigation request is fired."
      ]
    ]
  },
  {
    "module": "router-store",
    "api": "RouterRequestPayload",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterRequestPayload<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: T;\n  event: NavigationStart;\n};\n"
    ],
    "information": [["info", "Payload of ROUTER_REQUEST"]]
  },
  {
    "module": "router-store",
    "api": "routerCancelAction",
    "kind": "VariableDeclaration",
    "signatures": ["const routerCancelAction: any;\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "routerErrorAction",
    "kind": "VariableDeclaration",
    "signatures": ["const routerErrorAction: any;\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "routerNavigatedAction",
    "kind": "VariableDeclaration",
    "signatures": ["const routerNavigatedAction: any;\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "routerNavigationAction",
    "kind": "VariableDeclaration",
    "signatures": ["const routerNavigationAction: any;\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "routerRequestAction",
    "kind": "VariableDeclaration",
    "signatures": ["const routerRequestAction: any;\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "routerReducer",
    "kind": "FunctionDeclaration",
    "signatures": [
      "routerReducer< T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n>( state: RouterReducerState<T> | undefined, action: Action\n): RouterReducerState<T>;"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "RouterReducerState",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type RouterReducerState<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  state: T;\n  navigationId: number;\n};\n"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "StateKeyOrSelector",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type StateKeyOrSelector<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = string | Selector<any, RouterReducerState<T>>;\n"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "StoreRouterConnectingModule",
    "kind": "ClassDeclaration",
    "signatures": [
      "class StoreRouterConnectingModule {\n  static forRoot<\n    T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n  >(\n    config: StoreRouterConfig<T> = {}\n  ): ModuleWithProviders<StoreRouterConnectingModule>;\n}\n"
    ],
    "information": [
      [
        "info",
        "Connects RouterModule with StoreModule.",
        "",
        "During the navigation, before any guards or resolvers run, the router will dispatch",
        "a ROUTER_NAVIGATION action, which has the following signature:",
        "",
        "```",
        "export type RouterNavigationPayload = {",
        "  routerState: SerializedRouterStateSnapshot,",
        "  event: RoutesRecognized",
        "}",
        "```",
        "",
        "Either a reducer or an effect can be invoked in response to this action.",
        "If the invoked reducer throws, the navigation will be canceled.",
        "",
        "If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be",
        "dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.",
        "",
        "Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation",
        "which can be used to restore the consistency of the store.",
        "",
        "Usage:",
        "",
        "```typescript"
      ],
      [
        "NgModule({",
        "  declarations: [AppCmp, SimpleCmp],",
        "  imports: [",
        "    BrowserModule,",
        "    StoreModule.forRoot(mapOfReducers),",
        "    RouterModule.forRoot([",
        "      { path: '', component: SimpleCmp },",
        "      { path: 'next', component: SimpleCmp }",
        "    ]),",
        "    StoreRouterConnectingModule.forRoot()",
        "  ],",
        "  bootstrap: [AppCmp]",
        "})",
        "export class AppModule {",
        "}",
        "```"
      ]
    ]
  },
  {
    "module": "router-store",
    "api": "StoreRouterConfig",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface StoreRouterConfig<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> {\n  stateKey?: StateKeyOrSelector<T>;\n  serializer?: new (...args: any[]) => RouterStateSerializer;\n  navigationActionTiming?: NavigationActionTiming;\n  routerState?: RouterState;\n}\n"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "NavigationActionTiming",
    "kind": "EnumDeclaration",
    "signatures": [
      "export enum NavigationActionTiming {\n  PreActivation = 1,\n  PostActivation = 2,\n}\n"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "ROUTER_CONFIG",
    "kind": "VariableDeclaration",
    "signatures": ["const ROUTER_CONFIG: InjectionToken<unknown>;\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "DEFAULT_ROUTER_FEATURENAME",
    "kind": "VariableDeclaration",
    "signatures": ["const DEFAULT_ROUTER_FEATURENAME: 'router';\n"],
    "information": []
  },
  {
    "module": "router-store",
    "api": "RouterState",
    "kind": "EnumDeclaration",
    "signatures": ["export const enum RouterState {\n  Full,\n  Minimal,\n}\n"],
    "information": [
      [
        "info",
        "Full = Serializes the router event with DefaultRouterStateSerializer",
        "Minimal = Serializes the router event with MinimalRouterStateSerializer"
      ]
    ]
  },
  {
    "module": "router-store",
    "api": "RouterStateSerializer",
    "kind": "ClassDeclaration",
    "signatures": [
      "class RouterStateSerializer<\n  T extends BaseRouterStoreState = BaseRouterStoreState\n> {\n  abstract serialize(routerState: RouterStateSnapshot): T;\n}\n"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "BaseRouterStoreState",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface BaseRouterStoreState {\n  url: string;\n}\n"],
    "information": [
      [
        "info",
        "Simple router state.",
        "All custom router states / state serializers should have at least",
        "the properties of this interface."
      ]
    ]
  },
  {
    "module": "router-store",
    "api": "DefaultRouterStateSerializer",
    "kind": "ClassDeclaration",
    "signatures": [
      "class DefaultRouterStateSerializer\n  implements RouterStateSerializer<SerializedRouterStateSnapshot> {\n  serialize(routerState: RouterStateSnapshot): SerializedRouterStateSnapshot;\n}\n"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "SerializedRouterStateSnapshot",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface SerializedRouterStateSnapshot {\n  root: ActivatedRouteSnapshot;\n  url: string;\n\n  // inherited from BaseRouterStoreState\n  url: string;\n}\n"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "MinimalActivatedRouteSnapshot",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface MinimalActivatedRouteSnapshot {\n  routeConfig: ActivatedRouteSnapshot['routeConfig'];\n  url: ActivatedRouteSnapshot['url'];\n  params: ActivatedRouteSnapshot['params'];\n  queryParams: ActivatedRouteSnapshot['queryParams'];\n  fragment: ActivatedRouteSnapshot['fragment'];\n  data: ActivatedRouteSnapshot['data'];\n  outlet: ActivatedRouteSnapshot['outlet'];\n  firstChild?: MinimalActivatedRouteSnapshot;\n  children: MinimalActivatedRouteSnapshot[];\n}\n"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "MinimalRouterStateSnapshot",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface MinimalRouterStateSnapshot {\n  root: MinimalActivatedRouteSnapshot;\n  url: string;\n\n  // inherited from BaseRouterStoreState\n  url: string;\n}\n"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "MinimalRouterStateSerializer",
    "kind": "ClassDeclaration",
    "signatures": [
      "class MinimalRouterStateSerializer\n  implements RouterStateSerializer<MinimalRouterStateSnapshot> {\n  serialize(routerState: RouterStateSnapshot): MinimalRouterStateSnapshot;\n}\n"
    ],
    "information": []
  },
  {
    "module": "router-store",
    "api": "getSelectors",
    "kind": "FunctionDeclaration",
    "signatures": [
      "getSelectors<V>( selectState: (state: V) => RouterReducerState<any>\n): RouterStateSelectors<V>;",
      "getSelectors<V>( selectState: (state: V) => RouterReducerState<any>\n): RouterStateSelectors<V>;"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "isIvyEnabled",
    "kind": "FunctionDeclaration",
    "signatures": ["isIvyEnabled(tree: Tree, tsConfigPath: string): boolean;"],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "findNodes",
    "kind": "FunctionDeclaration",
    "signatures": [
      "findNodes( node: ts.Node, kind: ts.SyntaxKind, max = Infinity\n): ts.Node[];"
    ],
    "information": [
      [
        "info",
        "Find all nodes from the AST in the subtree of node of SyntaxKind kind."
      ],
      ["param", "node"],
      ["param", "kind"],
      ["param", "max The maximum number of items to return."],
      ["return", "all nodes of kind, or [] if none is found"]
    ]
  },
  {
    "module": "schematics-core",
    "api": "getSourceNodes",
    "kind": "FunctionDeclaration",
    "signatures": ["getSourceNodes(sourceFile: ts.SourceFile): ts.Node[];"],
    "information": [
      ["info", "Get all the nodes from a source."],
      ["param", "sourceFile The source file object."],
      [
        "returns",
        "{Observable<ts.Node>} An observable of all the nodes in the source."
      ]
    ]
  },
  {
    "module": "schematics-core",
    "api": "getDecoratorMetadata",
    "kind": "FunctionDeclaration",
    "signatures": [
      "getDecoratorMetadata( source: ts.SourceFile, identifier: string, module: string\n): ts.Node[];"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "getContentOfKeyLiteral",
    "kind": "FunctionDeclaration",
    "signatures": [
      "getContentOfKeyLiteral( _source: ts.SourceFile, node: ts.Node\n): string | null;"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "insertAfterLastOccurrence",
    "kind": "FunctionDeclaration",
    "signatures": [
      "insertAfterLastOccurrence( nodes: ts.Node[], toInsert: string, file: string, fallbackPos: number, syntaxKind?: ts.SyntaxKind\n): Change;"
    ],
    "information": [
      [
        "info",
        "Insert `toInsert` after the last occurence of `ts.SyntaxKind[nodes[i].kind]`",
        "or after the last of occurence of `syntaxKind` if the last occurence is a sub child",
        "of ts.SyntaxKind[nodes[i].kind] and save the changes in file."
      ],
      ["param", "nodes insert after the last occurence of nodes"],
      ["param", "toInsert string to insert"],
      ["param", "file file to insert changes into"],
      [
        "param",
        "fallbackPos position to insert if toInsert happens to be the first occurence"
      ],
      [
        "param",
        "syntaxKind the ts.SyntaxKind of the subchildren to insert after"
      ],
      ["return", "Change instance"],
      ["throw", "Error if toInsert is first occurence but fall back is not set"]
    ]
  },
  {
    "module": "schematics-core",
    "api": "insertImport",
    "kind": "FunctionDeclaration",
    "signatures": [
      "insertImport( source: ts.SourceFile, fileToEdit: string, symbolName: string, fileName: string, isDefault = false\n): Change;"
    ],
    "information": [
      [
        "info",
        "Add Import `import { symbolName } from fileName` if the import doesn't exit",
        "already. Assumes fileToEdit can be resolved and accessed."
      ],
      ["param", "fileToEdit (file we want to add import to)"],
      ["param", "symbolName (item to import)"],
      ["param", "fileName (path to the file)"],
      [
        "param",
        "isDefault (if true, import follows style for importing default exports)"
      ],
      ["return", "Change"]
    ]
  },
  {
    "module": "schematics-core",
    "api": "addBootstrapToModule",
    "kind": "FunctionDeclaration",
    "signatures": [
      "addBootstrapToModule( source: ts.SourceFile, modulePath: string, classifiedName: string, importPath: string\n): Change[];"
    ],
    "information": [
      [
        "info",
        "Custom function to insert an export into NgModule. It also imports it."
      ]
    ]
  },
  {
    "module": "schematics-core",
    "api": "addDeclarationToModule",
    "kind": "FunctionDeclaration",
    "signatures": [
      "addDeclarationToModule( source: ts.SourceFile, modulePath: string, classifiedName: string, importPath: string\n): Change[];"
    ],
    "information": [
      [
        "info",
        "Custom function to insert a declaration (component, pipe, directive)",
        "into NgModule declarations. It also imports the component."
      ]
    ]
  },
  {
    "module": "schematics-core",
    "api": "addExportToModule",
    "kind": "FunctionDeclaration",
    "signatures": [
      "addExportToModule( source: ts.SourceFile, modulePath: string, classifiedName: string, importPath: string\n): Change[];"
    ],
    "information": [
      [
        "info",
        "Custom function to insert an export into NgModule. It also imports it."
      ]
    ]
  },
  {
    "module": "schematics-core",
    "api": "addImportToModule",
    "kind": "FunctionDeclaration",
    "signatures": [
      "addImportToModule( source: ts.SourceFile, modulePath: string, classifiedName: string, importPath: string\n): Change[];"
    ],
    "information": [
      [
        "info",
        "Custom function to insert a declaration (component, pipe, directive)",
        "into NgModule declarations. It also imports the component."
      ]
    ]
  },
  {
    "module": "schematics-core",
    "api": "addProviderToModule",
    "kind": "FunctionDeclaration",
    "signatures": [
      "addProviderToModule( source: ts.SourceFile, modulePath: string, classifiedName: string, importPath: string\n): Change[];"
    ],
    "information": [
      [
        "info",
        "Custom function to insert a provider into NgModule. It also imports it."
      ]
    ]
  },
  {
    "module": "schematics-core",
    "api": "replaceImport",
    "kind": "FunctionDeclaration",
    "signatures": [
      "replaceImport( sourceFile: ts.SourceFile, path: Path, importFrom: string, importAsIs: string, importToBe: string\n): (ReplaceChange | RemoveChange)[];"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "containsProperty",
    "kind": "FunctionDeclaration",
    "signatures": [
      "containsProperty( objectLiteral: ts.ObjectLiteralExpression, propertyName: string\n);"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "Host",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface Host {}\n"],
    "information": [
      [
        "license",
        "Copyright Google Inc. All Rights Reserved.",
        "",
        "Use of this source code is governed by an MIT-style license that can be",
        "found in the LICENSE file at https:"
      ]
    ]
  },
  {
    "module": "schematics-core",
    "api": "Change",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface Change {\n  readonly path: string | null;\n  readonly order: number;\n  readonly description: string;\n}\n"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "NoopChange",
    "kind": "ClassDeclaration",
    "signatures": [
      "class NoopChange implements Change {\n  description = 'No operation.';\n  order = Infinity;\n  path = null;\n\n  apply();\n}\n"
    ],
    "information": [["info", "An operation that does nothing."]]
  },
  {
    "module": "schematics-core",
    "api": "InsertChange",
    "kind": "ClassDeclaration",
    "signatures": [
      "class InsertChange implements Change {\n  order: number;\n  description: string;\n\n  apply(host: Host);\n}\n"
    ],
    "information": [["info", "Will add text to the source code."]]
  },
  {
    "module": "schematics-core",
    "api": "RemoveChange",
    "kind": "ClassDeclaration",
    "signatures": [
      "class RemoveChange implements Change {\n  order: number;\n  description: string;\n\n  apply(host: Host): Promise<void>;\n}\n"
    ],
    "information": [["info", "Will remove text from the source code."]]
  },
  {
    "module": "schematics-core",
    "api": "ReplaceChange",
    "kind": "ClassDeclaration",
    "signatures": [
      "class ReplaceChange implements Change {\n  order: number;\n  description: string;\n\n  apply(host: Host): Promise<void>;\n}\n"
    ],
    "information": [["info", "Will replace text from the source code."]]
  },
  {
    "module": "schematics-core",
    "api": "createReplaceChange",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createReplaceChange( sourceFile: ts.SourceFile, node: ts.Node, oldText: string, newText: string\n): ReplaceChange;"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "createChangeRecorder",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createChangeRecorder( tree: Tree, path: string, changes: Change[]\n): UpdateRecorder;"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "commitChanges",
    "kind": "FunctionDeclaration",
    "signatures": [
      "commitChanges(tree: Tree, path: string, changes: Change[]);"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "AppConfig",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface AppConfig {\n  name?: string;\n  appRoot?: string;\n  root?: string;\n  outDir?: string;\n  assets?: (\n    | string\n    | {\n        /** * The pattern to match. */ glob?: string;\n        /** * The dir to search within. */ input?: string;\n        /** * The output path (relative to the outDir). */ output?: string;\n      }\n  )[];\n  deployUrl?: string;\n  baseHref?: string;\n  platform?: 'browser' | 'server';\n  index?: string;\n  main?: string;\n  polyfills?: string;\n  test?: string;\n  tsconfig?: string;\n  testTsconfig?: string;\n  prefix?: string;\n  serviceWorker?: boolean;\n  styles?: (string | { input?: string; [name: string]: any })[];\n  stylePreprocessorOptions?: {\n    /** * Paths to include. Paths will be resolved to project root. */ includePaths?: string[];\n  };\n  scripts?: (string | { input: string; [name: string]: any })[];\n  environmentSource?: string;\n  environments?: { [name: string]: any };\n  appShell?: { app: string; route: string };\n}\n"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "getWorkspace",
    "kind": "FunctionDeclaration",
    "signatures": ["getWorkspace(host: Tree): WorkspaceSchema;"],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "getWorkspacePath",
    "kind": "FunctionDeclaration",
    "signatures": ["getWorkspacePath(host: Tree): string;"],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "findModule",
    "kind": "FunctionDeclaration",
    "signatures": ["findModule(host: Tree, generateDir: string): Path;"],
    "information": [
      [
        "info",
        "Function to find the \"closest\" module to a generated file's path."
      ]
    ]
  },
  {
    "module": "schematics-core",
    "api": "findModuleFromOptions",
    "kind": "FunctionDeclaration",
    "signatures": [
      "findModuleFromOptions( host: Tree, options: ModuleOptions\n): Path | undefined;"
    ],
    "information": [
      [
        "info",
        "Find the module referred by a set of options passed to the schematics."
      ]
    ]
  },
  {
    "module": "schematics-core",
    "api": "buildRelativePath",
    "kind": "FunctionDeclaration",
    "signatures": ["buildRelativePath(from: string, to: string): string;"],
    "information": [
      ["info", "Build a relative path from one file path to another file path."]
    ]
  },
  {
    "module": "schematics-core",
    "api": "ModuleOptions",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface ModuleOptions {\n  module?: string;\n  name: string;\n  flat?: boolean;\n  path?: string;\n  skipImport?: boolean;\n}\n"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "findPropertyInAstObject",
    "kind": "FunctionDeclaration",
    "signatures": [
      "findPropertyInAstObject( node: JsonAstObject, propertyName: string\n): JsonAstNode | null;"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "addReducerToState",
    "kind": "FunctionDeclaration",
    "signatures": ["addReducerToState(options: any): Rule;"],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "addReducerToStateInterface",
    "kind": "FunctionDeclaration",
    "signatures": [
      "addReducerToStateInterface( source: ts.SourceFile, reducersPath: string, options: { name: string; plural: boolean }\n): Change;"
    ],
    "information": [
      ["info", "Insert the reducer into the first defined top level interface"]
    ]
  },
  {
    "module": "schematics-core",
    "api": "addReducerImportToNgModule",
    "kind": "FunctionDeclaration",
    "signatures": ["addReducerImportToNgModule(options: any): Rule;"],
    "information": [["info", "Add reducer feature to NgModule"]]
  },
  {
    "module": "schematics-core",
    "api": "addReducerToActionReducerMap",
    "kind": "FunctionDeclaration",
    "signatures": [
      "addReducerToActionReducerMap( source: ts.SourceFile, reducersPath: string, options: { name: string; plural: boolean }\n): Change;"
    ],
    "information": [["info", "Insert the reducer into the ActionReducerMap"]]
  },
  {
    "module": "schematics-core",
    "api": "omit",
    "kind": "FunctionDeclaration",
    "signatures": [
      "omit<T extends { [key: string]: any }>( object: T, keyToRemove: keyof T\n): Partial<T>;"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "getProjectPath",
    "kind": "FunctionDeclaration",
    "signatures": [
      "getProjectPath( host: Tree, options: { project?: string | undefined; path?: string | undefined }\n);"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "getProject",
    "kind": "FunctionDeclaration",
    "signatures": [
      "getProject( host: Tree, options: { project?: string | undefined; path?: string | undefined }\n): WorkspaceProject;"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "isLib",
    "kind": "FunctionDeclaration",
    "signatures": [
      "isLib( host: Tree, options: { project?: string | undefined; path?: string | undefined }\n);"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "stringUtils",
    "kind": "VariableDeclaration",
    "signatures": [
      "const stringUtils: {\n  dasherize: typeof dasherize;\n  decamelize: typeof decamelize;\n  camelize: typeof camelize;\n  classify: typeof classify;\n  underscore: typeof underscore;\n  group: typeof group;\n  capitalize: typeof capitalize;\n  featurePath: typeof featurePath;\n  pluralize: typeof pluralize;\n};\n"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "updatePackage",
    "kind": "FunctionDeclaration",
    "signatures": ["updatePackage(name: string): Rule;"],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "parseName",
    "kind": "FunctionDeclaration",
    "signatures": ["parseName(path: string, name: string): Location;"],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "addPackageToPackageJson",
    "kind": "FunctionDeclaration",
    "signatures": [
      "addPackageToPackageJson( host: Tree, type: string, pkg: string, version: string\n): Tree;"
    ],
    "information": [["info", "Adds a package to the package.json"]]
  },
  {
    "module": "schematics-core",
    "api": "platformVersion",
    "kind": "VariableDeclaration",
    "signatures": ["const platformVersion: '^10.0.0-rc.0';\n"],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "visitTSSourceFiles",
    "kind": "FunctionDeclaration",
    "signatures": [
      "visitTSSourceFiles<Result = void>( tree: Tree, visitor: ( sourceFile: ts.SourceFile, tree: Tree, result?: Result ) => Result | undefined\n): Result | undefined;"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "visitNgModuleImports",
    "kind": "FunctionDeclaration",
    "signatures": [
      "visitNgModuleImports( sourceFile: ts.SourceFile, callback: ( importNode: ts.PropertyAssignment, elementExpressions: ts.NodeArray<ts.Expression> ) => void\n);"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "visitNgModuleExports",
    "kind": "FunctionDeclaration",
    "signatures": [
      "visitNgModuleExports( sourceFile: ts.SourceFile, callback: ( exportNode: ts.PropertyAssignment, elementExpressions: ts.NodeArray<ts.Expression> ) => void\n);"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "visitComponents",
    "kind": "FunctionDeclaration",
    "signatures": [
      "visitComponents( sourceFile: ts.SourceFile, callback: ( classDeclarationNode: ts.ClassDeclaration, decoratorExpressionNode: ts.ObjectLiteralExpression ) => void\n);"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "visitDecorator",
    "kind": "FunctionDeclaration",
    "signatures": [
      "visitDecorator( sourceFile: ts.SourceFile, decoratorName: string, callback: ( classDeclarationNode: ts.ClassDeclaration, decoratorExpressionNode: ts.ObjectLiteralExpression ) => void\n);"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "visitNgModules",
    "kind": "FunctionDeclaration",
    "signatures": [
      "visitNgModules( sourceFile: ts.SourceFile, callback: ( classDeclarationNode: ts.ClassDeclaration, decoratorExpressionNode: ts.ObjectLiteralExpression ) => void\n);"
    ],
    "information": []
  },
  {
    "module": "schematics-core",
    "api": "visitTemplates",
    "kind": "FunctionDeclaration",
    "signatures": [
      "visitTemplates( tree: Tree, visitor: ( template: { fileName: string; content: string; inline: boolean; start: number; }, tree: Tree ) => void\n): void;"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "Action",
    "kind": "InterfaceDeclaration",
    "signatures": ["interface Action {\n  type: string;\n}\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "ActionCreator",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type ActionCreator<T extends string = string, C extends Creator = Creator> = C &\n  TypedAction<T>;\n"
    ],
    "information": [["info", "See `Creator`."]]
  },
  {
    "module": "store",
    "api": "ActionReducer",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface ActionReducer<T, V extends Action = Action> {}\n"
    ],
    "information": [
      [
        "info",
        "A function that takes an `Action` and a `State`, and returns a `State`.",
        "See `createReducer`."
      ]
    ]
  },
  {
    "module": "store",
    "api": "ActionReducerMap",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type ActionReducerMap<T, V extends Action = Action> = {\n  [p in keyof T]: ActionReducer<T[p], V>;\n};\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "ActionReducerFactory",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface ActionReducerFactory<T, V extends Action = Action> {}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "ActionType",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type ActionType<A> = A extends ActionCreator<infer T, infer C>\n  ? ReturnType<C> & { type: T }\n  : never;\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "Creator",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type Creator<\n  P extends any[] = any[],\n  R extends object = object\n> = FunctionWithParametersType<P, R>;\n"
    ],
    "information": [
      [
        "info",
        "A function that returns an object in the shape of the `Action` interface.  Configured using `createAction`."
      ]
    ]
  },
  {
    "module": "store",
    "api": "MetaReducer",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type MetaReducer<T = any, V extends Action = Action> = (\n  reducer: ActionReducer<T, V>\n) => ActionReducer<T, V>;\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "Selector",
    "kind": "TypeAliasDeclaration",
    "signatures": ["type Selector<T, V> = (state: T) => V;\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "SelectorWithProps",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type SelectorWithProps<State, Props, Result> = (\n  state: State,\n  props: Props\n) => Result;\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "RuntimeChecks",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface RuntimeChecks {\n  strictStateSerializability: boolean;\n  strictActionSerializability: boolean;\n  strictStateImmutability: boolean;\n  strictActionImmutability: boolean;\n  strictActionWithinNgZone: boolean;\n  strictActionTypeUniqueness?: boolean;\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "createAction",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createAction<T extends string>( type: T\n): ActionCreator<T, () => TypedAction<T>>;",
      "createAction<T extends string, P extends object>( type: T, config: Props<P> & NotAllowedCheck<P>\n): ActionCreator<T, (props: P & NotAllowedCheck<P>) => P & TypedAction<T>>;",
      "createAction< T extends string, P extends any[], R extends object\n>( type: T, creator: Creator<P, R> & NotAllowedCheck<R>\n): FunctionWithParametersType<P, R & TypedAction<T>> & TypedAction<T>;",
      "createAction<T extends string, C extends Creator>( type: T, config?: { _as: 'props' } | C\n): ActionCreator<T>;"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "props",
    "kind": "FunctionDeclaration",
    "signatures": ["props<P extends object>(): Props<P>;"],
    "information": []
  },
  {
    "module": "store",
    "api": "union",
    "kind": "FunctionDeclaration",
    "signatures": [
      "union< C extends { [key: string]: ActionCreator<string, Creator> }\n>(creators: C): ReturnType<C[keyof C]>;"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "Store",
    "kind": "ClassDeclaration",
    "signatures": [
      "class Store<T = object> extends Observable<T> implements Observer<Action> {\n  select<Props = any, K = any>(\n    pathOrMapFn: ((state: T, props?: Props) => K) | string,\n    ...paths: string[]\n  ): Observable<any>;\n  lift<R>(operator: Operator<T, R>): Store<R>;\n  dispatch<V extends Action = Action>(\n    action: V &\n      FunctionIsNotAllowed<\n        V,\n        'Functions are not allowed to be dispatched. Did you forget to call the action creator function?'\n      >\n  );\n  next(action: Action);\n  error(err: any);\n  complete();\n  addReducer<State, Actions extends Action = Action>(\n    key: string,\n    reducer: ActionReducer<State, Actions>\n  );\n  removeReducer<Key extends Extract<keyof T, string>>(key: Key);\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "select",
    "kind": "FunctionDeclaration",
    "signatures": [
      "select<T, Props, K>( mapFn: (state: T, props: Props) => K, props?: Props\n): (source$: Observable<T>) => Observable<K>;",
      "select<T, a extends keyof T>( key: a\n): (source$: Observable<T>) => Observable<T[a]>;",
      "select<T, a extends keyof T, b extends keyof T[a]>( key1: a, key2: b\n): (source$: Observable<T>) => Observable<T[a][b]>;",
      "select< T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b]\n>( key1: a, key2: b, key3: c\n): (source$: Observable<T>) => Observable<T[a][b][c]>;",
      "select< T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c]\n>( key1: a, key2: b, key3: c, key4: d\n): (source$: Observable<T>) => Observable<T[a][b][c][d]>;",
      "select< T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d]\n>( key1: a, key2: b, key3: c, key4: d, key5: e\n): (source$: Observable<T>) => Observable<T[a][b][c][d][e]>;",
      "select< T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d], f extends keyof T[a][b][c][d][e]\n>( key1: a, key2: b, key3: c, key4: d, key5: e, key6: f\n): (source$: Observable<T>) => Observable<T[a][b][c][d][e][f]>;",
      "select< T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d], f extends keyof T[a][b][c][d][e], K = any\n>( key1: a, key2: b, key3: c, key4: d, key5: e, key6: f, ...paths: string[]\n): (source$: Observable<T>) => Observable<K>;",
      "select<T, Props, K>( pathOrMapFn: ((state: T, props?: Props) => any) | string, propsOrPath?: Props | string, ...paths: string[]\n);"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "combineReducers",
    "kind": "FunctionDeclaration",
    "signatures": [
      "combineReducers<T, V extends Action = Action>( reducers: ActionReducerMap<T, V>, initialState?: Partial<T>\n): ActionReducer<T, V>;",
      "combineReducers( reducers: any, initialState: any = {}\n): ActionReducer<any, Action>;"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "compose",
    "kind": "FunctionDeclaration",
    "signatures": [
      "compose<A>(): (i: A) => A;",
      "compose<A, B>(b: (i: A) => B): (i: A) => B;",
      "compose<A, B, C>(c: (i: B) => C, b: (i: A) => B): (i: A) => C;",
      "compose<A, B, C, D>( d: (i: C) => D, c: (i: B) => C, b: (i: A) => B\n): (i: A) => D;",
      "compose<A, B, C, D, E>( e: (i: D) => E, d: (i: C) => D, c: (i: B) => C, b: (i: A) => B\n): (i: A) => E;",
      "compose<A, B, C, D, E, F>( f: (i: E) => F, e: (i: D) => E, d: (i: C) => D, c: (i: B) => C, b: (i: A) => B\n): (i: A) => F;",
      "compose<A = any, F = any>(...functions: any[]): (i: A) => F;",
      "compose(...functions: any[]);"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "createReducerFactory",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createReducerFactory<T, V extends Action = Action>( reducerFactory: ActionReducerFactory<T, V>, metaReducers?: MetaReducer<T, V>[]\n): ActionReducerFactory<T, V>;"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "ActionsSubject",
    "kind": "ClassDeclaration",
    "signatures": [
      "class ActionsSubject extends BehaviorSubject<Action> implements OnDestroy {\n  next(action: Action): void;\n  complete();\n  ngOnDestroy();\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "INIT",
    "kind": "VariableDeclaration",
    "signatures": ["const INIT: '@ngrx/store/init';\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "setNgrxMockEnvironment",
    "kind": "FunctionDeclaration",
    "signatures": ["setNgrxMockEnvironment(value: boolean): void;"],
    "information": []
  },
  {
    "module": "store",
    "api": "isNgrxMockEnvironment",
    "kind": "FunctionDeclaration",
    "signatures": ["isNgrxMockEnvironment(): boolean;"],
    "information": []
  },
  {
    "module": "store",
    "api": "ReducerManager",
    "kind": "ClassDeclaration",
    "signatures": [
      "class ReducerManager extends BehaviorSubject<ActionReducer<any, any>>\n  implements OnDestroy {\n  addFeature(feature: StoreFeature<any, any>);\n  addFeatures(features: StoreFeature<any, any>[]);\n  removeFeature(feature: StoreFeature<any, any>);\n  removeFeatures(features: StoreFeature<any, any>[]);\n  addReducer(key: string, reducer: ActionReducer<any, any>);\n  addReducers(reducers: { [key: string]: ActionReducer<any, any> });\n  removeReducer(featureKey: string);\n  removeReducers(featureKeys: string[]);\n  ngOnDestroy();\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "ReducerObservable",
    "kind": "ClassDeclaration",
    "signatures": [
      "class ReducerObservable extends Observable<ActionReducer<any, any>> {}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "ReducerManagerDispatcher",
    "kind": "ClassDeclaration",
    "signatures": [
      "class ReducerManagerDispatcher extends ActionsSubject {}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "UPDATE",
    "kind": "VariableDeclaration",
    "signatures": ["const UPDATE: '@ngrx/store/update-reducers';\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "ScannedActionsSubject",
    "kind": "ClassDeclaration",
    "signatures": [
      "class ScannedActionsSubject extends Subject<Action> implements OnDestroy {\n  ngOnDestroy();\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "createSelector",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createSelector<State, S1, Result>( s1: Selector<State, S1>, projector: (s1: S1) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, Result>( s1: SelectorWithProps<State, Props, S1>, projector: (s1: S1, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, Result>( selectors: [Selector<State, S1>], projector: (s1: S1) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, Result>( selectors: [SelectorWithProps<State, Props, S1>], projector: (s1: S1, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, Result>( s1: Selector<State, S1>, s2: Selector<State, S2>, projector: (s1: S1, s2: S2) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, S2, Result>( s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, projector: (s1: S1, s2: S2, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, Result>( selectors: [Selector<State, S1>, Selector<State, S2>], projector: (s1: S1, s2: S2) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, S2, Result>( selectors: [ SelectorWithProps<State, Props, S1>, SelectorWithProps<State, Props, S2> ], projector: (s1: S1, s2: S2, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, Result>( s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, projector: (s1: S1, s2: S2, s3: S3) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, S2, S3, Result>( s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, projector: (s1: S1, s2: S2, s3: S3, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, Result>( selectors: [Selector<State, S1>, Selector<State, S2>, Selector<State, S3>], projector: (s1: S1, s2: S2, s3: S3) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, S2, S3, Result>( selectors: [ SelectorWithProps<State, Props, S1>, SelectorWithProps<State, Props, S2>, SelectorWithProps<State, Props, S3> ], projector: (s1: S1, s2: S2, s3: S3, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, S4, Result>( s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, s4: Selector<State, S4>, projector: (s1: S1, s2: S2, s3: S3, s4: S4) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, S2, S3, S4, Result>( s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, s4: SelectorWithProps<State, Props, S4>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, S4, Result>( selectors: [ Selector<State, S1>, Selector<State, S2>, Selector<State, S3>, Selector<State, S4> ], projector: (s1: S1, s2: S2, s3: S3, s4: S4) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, S2, S3, S4, Result>( selectors: [ SelectorWithProps<State, Props, S1>, SelectorWithProps<State, Props, S2>, SelectorWithProps<State, Props, S3>, SelectorWithProps<State, Props, S4> ], projector: (s1: S1, s2: S2, s3: S3, s4: S4, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, S4, S5, Result>( s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, s4: Selector<State, S4>, s5: Selector<State, S5>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, S2, S3, S4, S5, Result>( s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, s4: SelectorWithProps<State, Props, S4>, s5: SelectorWithProps<State, Props, S5>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, S4, S5, Result>( selectors: [ Selector<State, S1>, Selector<State, S2>, Selector<State, S3>, Selector<State, S4>, Selector<State, S5> ], projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, S2, S3, S4, S5, Result>( selectors: [ SelectorWithProps<State, Props, S1>, SelectorWithProps<State, Props, S2>, SelectorWithProps<State, Props, S3>, SelectorWithProps<State, Props, S4>, SelectorWithProps<State, Props, S5> ], projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, props: Props) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, S4, S5, S6, Result>( s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, s4: Selector<State, S4>, s5: Selector<State, S5>, s6: Selector<State, S6>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, S2, S3, S4, S5, S6, Result>( s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, s4: SelectorWithProps<State, Props, S4>, s5: SelectorWithProps<State, Props, S5>, s6: SelectorWithProps<State, Props, S6>, projector: ( s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, props: Props ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, S4, S5, S6, Result>( selectors: [ Selector<State, S1>, Selector<State, S2>, Selector<State, S3>, Selector<State, S4>, Selector<State, S5>, Selector<State, S6> ], projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector<State, Props, S1, S2, S3, S4, S5, S6, Result>( selectors: [ SelectorWithProps<State, Props, S1>, SelectorWithProps<State, Props, S2>, SelectorWithProps<State, Props, S3>, SelectorWithProps<State, Props, S4>, SelectorWithProps<State, Props, S5>, SelectorWithProps<State, Props, S6> ], projector: ( s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, props: Props ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, S4, S5, S6, S7, Result>( s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, s4: Selector<State, S4>, s5: Selector<State, S5>, s6: Selector<State, S6>, s7: Selector<State, S7>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector< State, Props, S1, S2, S3, S4, S5, S6, S7, Result\n>( s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, s4: SelectorWithProps<State, Props, S4>, s5: SelectorWithProps<State, Props, S5>, s6: SelectorWithProps<State, Props, S6>, s7: SelectorWithProps<State, Props, S7>, projector: ( s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7, props: Props ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, S4, S5, S6, S7, Result>( selectors: [ Selector<State, S1>, Selector<State, S2>, Selector<State, S3>, Selector<State, S4>, Selector<State, S5>, Selector<State, S6>, Selector<State, S7> ], projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector< State, Props, S1, S2, S3, S4, S5, S6, S7, Result\n>( selectors: [ SelectorWithProps<State, Props, S1>, SelectorWithProps<State, Props, S2>, SelectorWithProps<State, Props, S3>, SelectorWithProps<State, Props, S4>, SelectorWithProps<State, Props, S5>, SelectorWithProps<State, Props, S6>, SelectorWithProps<State, Props, S7> ], projector: ( s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7, props: Props ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, S4, S5, S6, S7, S8, Result>( s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, s4: Selector<State, S4>, s5: Selector<State, S5>, s6: Selector<State, S6>, s7: Selector<State, S7>, s8: Selector<State, S8>, projector: ( s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7, s8: S8 ) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector< State, Props, S1, S2, S3, S4, S5, S6, S7, S8, Result\n>( s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, s4: SelectorWithProps<State, Props, S4>, s5: SelectorWithProps<State, Props, S5>, s6: SelectorWithProps<State, Props, S6>, s7: SelectorWithProps<State, Props, S7>, s8: SelectorWithProps<State, Props, S8>, projector: ( s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7, s8: S8, props: Props ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector<State, S1, S2, S3, S4, S5, S6, S7, S8, Result>( selectors: [ Selector<State, S1>, Selector<State, S2>, Selector<State, S3>, Selector<State, S4>, Selector<State, S5>, Selector<State, S6>, Selector<State, S7>, Selector<State, S8> ], projector: ( s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7, s8: S8 ) => Result\n): MemoizedSelector<State, Result>;",
      "createSelector< State, Props, S1, S2, S3, S4, S5, S6, S7, S8, Result\n>( selectors: [ SelectorWithProps<State, Props, S1>, SelectorWithProps<State, Props, S2>, SelectorWithProps<State, Props, S3>, SelectorWithProps<State, Props, S4>, SelectorWithProps<State, Props, S5>, SelectorWithProps<State, Props, S6>, SelectorWithProps<State, Props, S7>, SelectorWithProps<State, Props, S8> ], projector: ( s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7, s8: S8, props: Props ) => Result\n): MemoizedSelectorWithProps<State, Props, Result>;",
      "createSelector( ...input: any[]\n): MemoizedSelector<any, any> | MemoizedSelectorWithProps<any, any, any>;"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "createSelectorFactory",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createSelectorFactory<T = any, V = any>( memoize: MemoizeFn\n): (...input: any[]) => MemoizedSelector<T, V>;",
      "createSelectorFactory<T = any, V = any>( memoize: MemoizeFn, options: SelectorFactoryConfig<T, V>\n): (...input: any[]) => MemoizedSelector<T, V>;",
      "createSelectorFactory<T = any, Props = any, V = any>( memoize: MemoizeFn\n): (...input: any[]) => MemoizedSelectorWithProps<T, Props, V>;",
      "createSelectorFactory<T = any, Props = any, V = any>( memoize: MemoizeFn, options: SelectorFactoryConfig<T, V>\n): (...input: any[]) => MemoizedSelectorWithProps<T, Props, V>;",
      "createSelectorFactory( memoize: MemoizeFn, options: SelectorFactoryConfig<any, any> = { stateFn: defaultStateFn, }\n);"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "createFeatureSelector",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createFeatureSelector<T>( featureName: string\n): MemoizedSelector<object, T>;",
      "createFeatureSelector<T, V>( featureName: keyof T\n): MemoizedSelector<T, V>;",
      "createFeatureSelector( featureName: any\n): MemoizedSelector<any, any>;"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "defaultMemoize",
    "kind": "FunctionDeclaration",
    "signatures": [
      "defaultMemoize( projectionFn: AnyFn, isArgumentsEqual = isEqualCheck, isResultEqual = isEqualCheck\n): MemoizedProjection;"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "defaultStateFn",
    "kind": "FunctionDeclaration",
    "signatures": [
      "defaultStateFn( state: any, selectors: Selector<any, any>[] | SelectorWithProps<any, any, any>[], props: any, memoizedProjector: MemoizedProjection\n): any;"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "MemoizeFn",
    "kind": "TypeAliasDeclaration",
    "signatures": ["type MemoizeFn = (t: AnyFn) => MemoizedProjection;\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "MemoizedProjection",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type MemoizedProjection = {\n  memoized: AnyFn;\n  reset: () => void;\n  setResult: (result?: any) => void;\n  clearResult: () => void;\n};\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "MemoizedSelector",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface MemoizedSelector<\n  State,\n  Result,\n  ProjectorFn = DefaultProjectorFn<Result>\n> {\n  projector: ProjectorFn;\n  setResult: (result?: Result) => void;\n  clearResult: () => void;\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "MemoizedSelectorWithProps",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface MemoizedSelectorWithProps<\n  State,\n  Props,\n  Result,\n  ProjectorFn = DefaultProjectorFn<Result>\n> {\n  projector: ProjectorFn;\n  setResult: (result?: Result) => void;\n  clearResult: () => void;\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "resultMemoize",
    "kind": "FunctionDeclaration",
    "signatures": [
      "resultMemoize( projectionFn: AnyFn, isResultEqual: ComparatorFn\n);"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "DefaultProjectorFn",
    "kind": "TypeAliasDeclaration",
    "signatures": ["type DefaultProjectorFn<T> = (...args: any[]) => T;\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "State",
    "kind": "ClassDeclaration",
    "signatures": [
      "class State<T> extends BehaviorSubject<any> implements OnDestroy {\n  static readonly INIT = INIT;\n\n  ngOnDestroy();\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "StateObservable",
    "kind": "ClassDeclaration",
    "signatures": ["class StateObservable extends Observable<any> {}\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "reduceState",
    "kind": "FunctionDeclaration",
    "signatures": [
      "reduceState<T, V extends Action = Action>( stateActionPair: StateActionPair<T, V> = { state: undefined }, [action, reducer]: [V, ActionReducer<T, V>]\n): StateActionPair<T, V>;"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "INITIAL_STATE",
    "kind": "VariableDeclaration",
    "signatures": ["const INITIAL_STATE: InjectionToken<unknown>;\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "REDUCER_FACTORY",
    "kind": "VariableDeclaration",
    "signatures": ["const REDUCER_FACTORY: InjectionToken<unknown>;\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "INITIAL_REDUCERS",
    "kind": "VariableDeclaration",
    "signatures": ["const INITIAL_REDUCERS: InjectionToken<unknown>;\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "STORE_FEATURES",
    "kind": "VariableDeclaration",
    "signatures": ["const STORE_FEATURES: InjectionToken<unknown>;\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "META_REDUCERS",
    "kind": "VariableDeclaration",
    "signatures": [
      "const META_REDUCERS: InjectionToken<\n  MetaReducer<\n    any,\n    import('C:/Users/tdeschryver/dev/platform/modules/store/src/models').Action\n  >[]\n>;\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "FEATURE_REDUCERS",
    "kind": "VariableDeclaration",
    "signatures": ["const FEATURE_REDUCERS: InjectionToken<unknown>;\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "USER_PROVIDED_META_REDUCERS",
    "kind": "VariableDeclaration",
    "signatures": [
      "const USER_PROVIDED_META_REDUCERS: InjectionToken<\n  MetaReducer<\n    any,\n    import('C:/Users/tdeschryver/dev/platform/modules/store/src/models').Action\n  >[]\n>;\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "USER_RUNTIME_CHECKS",
    "kind": "VariableDeclaration",
    "signatures": [
      "const USER_RUNTIME_CHECKS: InjectionToken<RuntimeChecks>;\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "StoreModule",
    "kind": "ClassDeclaration",
    "signatures": [
      "class StoreModule {\n  static forRoot(\n    reducers:\n      | ActionReducerMap<any, any>\n      | InjectionToken<ActionReducerMap<any, any>>,\n    config: RootStoreConfig<any, any> = {}\n  ): ModuleWithProviders<StoreRootModule>;\n  static forFeature(\n    featureName: string,\n    reducers:\n      | ActionReducerMap<any, any>\n      | InjectionToken<ActionReducerMap<any, any>>\n      | ActionReducer<any, any>\n      | InjectionToken<ActionReducer<any, any>>,\n    config: StoreConfig<any, any> | InjectionToken<StoreConfig<any, any>> = {}\n  ): ModuleWithProviders<StoreFeatureModule>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "StoreRootModule",
    "kind": "ClassDeclaration",
    "signatures": ["class StoreRootModule {}\n"],
    "information": []
  },
  {
    "module": "store",
    "api": "StoreFeatureModule",
    "kind": "ClassDeclaration",
    "signatures": [
      "class StoreFeatureModule implements OnDestroy {\n  ngOnDestroy();\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "RootStoreConfig",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface RootStoreConfig<T, V extends Action = Action> {\n  runtimeChecks?: Partial<RuntimeChecks>;\n\n  // inherited from StoreConfig\n  initialState?: InitialState<T>;\n  reducerFactory?: ActionReducerFactory<T, V>;\n  metaReducers?: MetaReducer<T, V>[];\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "StoreConfig",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface StoreConfig<T, V extends Action = Action> {\n  initialState?: InitialState<T>;\n  reducerFactory?: ActionReducerFactory<T, V>;\n  metaReducers?: MetaReducer<T, V>[];\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "On",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface On<S> {\n  reducer: ActionReducer<S>;\n  types: string[];\n}\n"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "on",
    "kind": "FunctionDeclaration",
    "signatures": [
      "on<C1 extends ActionCreator, S>( creator1: C1, reducer: OnReducer<S, [C1]>\n): On<S>;",
      "on<C1 extends ActionCreator, C2 extends ActionCreator, S>( creator1: C1, creator2: C2, reducer: OnReducer<S, [C1, C2]>\n): On<S>;",
      "on< C1 extends ActionCreator, C2 extends ActionCreator, C3 extends ActionCreator, S\n>( creator1: C1, creator2: C2, creator3: C3, reducer: OnReducer<S, [C1, C2, C3]>\n): On<S>;",
      "on< C1 extends ActionCreator, C2 extends ActionCreator, C3 extends ActionCreator, C4 extends ActionCreator, S\n>( creator1: C1, creator2: C2, creator3: C3, creator4: C4, reducer: OnReducer<S, [C1, C2, C3, C4]>\n): On<S>;",
      "on< C1 extends ActionCreator, C2 extends ActionCreator, C3 extends ActionCreator, C4 extends ActionCreator, C5 extends ActionCreator, S\n>( creator1: C1, creator2: C2, creator3: C3, creator4: C4, creator5: C5, reducer: OnReducer<S, [C1, C2, C3, C4, C5]>\n): On<S>;",
      "on< C1 extends ActionCreator, C2 extends ActionCreator, C3 extends ActionCreator, C4 extends ActionCreator, C5 extends ActionCreator, C6 extends ActionCreator, S\n>( creator1: C1, creator2: C2, creator3: C3, creator4: C4, creator5: C5, creator6: C6, reducer: OnReducer<S, [C1, C2, C3, C4, C5, C6]>\n): On<S>;",
      "on< C1 extends ActionCreator, C2 extends ActionCreator, C3 extends ActionCreator, C4 extends ActionCreator, C5 extends ActionCreator, C6 extends ActionCreator, C7 extends ActionCreator, S\n>( creator1: C1, creator2: C2, creator3: C3, creator4: C4, creator5: C5, creator6: C6, creator7: C7, reducer: OnReducer<S, [C1, C2, C3, C4, C5, C6, C7]>\n): On<S>;",
      "on< C1 extends ActionCreator, C2 extends ActionCreator, C3 extends ActionCreator, C4 extends ActionCreator, C5 extends ActionCreator, C6 extends ActionCreator, C7 extends ActionCreator, C8 extends ActionCreator, S\n>( creator1: C1, creator2: C2, creator3: C3, creator4: C4, creator5: C5, creator6: C6, creator7: C7, creator8: C8, reducer: OnReducer<S, [C1, C2, C3, C4, C5, C6, C7, C8]>\n): On<S>;",
      "on< C1 extends ActionCreator, C2 extends ActionCreator, C3 extends ActionCreator, C4 extends ActionCreator, C5 extends ActionCreator, C6 extends ActionCreator, C7 extends ActionCreator, C8 extends ActionCreator, C9 extends ActionCreator, S\n>( creator1: C1, creator2: C2, creator3: C3, creator4: C4, creator5: C5, creator6: C6, creator7: C7, creator8: C8, creator9: C9, reducer: OnReducer<S, [C1, C2, C3, C4, C5, C6, C7, C8, C9]>\n): On<S>;",
      "on< C1 extends ActionCreator, C2 extends ActionCreator, C3 extends ActionCreator, C4 extends ActionCreator, C5 extends ActionCreator, C6 extends ActionCreator, C7 extends ActionCreator, C8 extends ActionCreator, C9 extends ActionCreator, C10 extends ActionCreator, S\n>( creator1: C1, creator2: C2, creator3: C3, creator4: C4, creator5: C5, creator6: C6, creator7: C7, creator8: C8, creator9: C9, creator10: C10, reducer: OnReducer<S, [C1, C2, C3, C4, C5, C6, C7, C8, C9, C10]>\n): On<S>;",
      "on<S>( creator: ActionCreator, ...rest: (ActionCreator | OnReducer<S, [ActionCreator]>)[]\n): On<S>;",
      "on( ...args: (ActionCreator | Function)[]\n): { reducer: Function; types: string[] };"
    ],
    "information": []
  },
  {
    "module": "store",
    "api": "createReducer",
    "kind": "FunctionDeclaration",
    "signatures": [
      "createReducer<S, A extends Action = Action>( initialState: S, ...ons: On<S>[]\n): ActionReducer<S, A>;"
    ],
    "information": [
      [
        "description",
        "Creates a reducer function to handle state transitions.",
        "",
        "Reducer creators reduce the explicitness of reducer functions with switch statements."
      ],
      [
        "param",
        "initialState Provides a state value if the current state is `undefined`, as it is initially."
      ],
      ["param", "ons Associations between actions and state changes."],
      ["returns", "A reducer function."],
      [
        "usageNotes",
        "",
        "- Must be used with `ActionCreator`'s (returned by `createAction`). Cannot be used with class-based action creators.",
        "- The returned `ActionReducer` should additionally be wrapped with another function, if you are using View Engine AOT.",
        "In case you are using Ivy (or only JIT View Engine) the extra wrapper function is not required.",
        "",
        "**Declaring a reducer creator**",
        "",
        "```ts",
        "export const reducer = createReducer(",
        "  initialState,",
        "  on(",
        "    featureActions.actionOne,",
        "    featureActions.actionTwo,",
        "    (state, { updatedValue }) => ({ ...state, prop: updatedValue })",
        "  ),",
        "  on(featureActions.actionThree, () => initialState);",
        ");",
        "```",
        "",
        "**Declaring a reducer creator using a wrapper function (Only needed if using View Engine AOT)**",
        "",
        "```ts",
        "const featureReducer = createReducer(",
        "  initialState,",
        "  on(",
        "    featureActions.actionOne,",
        "    featureActions.actionTwo,",
        "    (state, { updatedValue }) => ({ ...state, prop: updatedValue })",
        "  ),",
        "  on(featureActions.actionThree, () => initialState);",
        ");",
        "",
        "export function reducer(state: State | undefined, action: Action) {",
        "  return featureReducer(state, action);",
        "}",
        "```"
      ]
    ]
  },
  {
    "module": "store-devtools",
    "api": "StoreDevtoolsModule",
    "kind": "ClassDeclaration",
    "signatures": [
      "class StoreDevtoolsModule {\n  static instrument(\n    options: StoreDevtoolsOptions = {}\n  ): ModuleWithProviders<StoreDevtoolsModule>;\n}\n"
    ],
    "information": []
  },
  {
    "module": "store-devtools",
    "api": "LiftedState",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface LiftedState {\n  monitorState: any;\n  nextActionId: number;\n  actionsById: LiftedActions;\n  stagedActionIds: number[];\n  skippedActionIds: number[];\n  committedState: any;\n  currentStateIndex: number;\n  computedStates: ComputedState[];\n  isLocked: boolean;\n  isPaused: boolean;\n}\n"
    ],
    "information": []
  },
  {
    "module": "store-devtools",
    "api": "RECOMPUTE",
    "kind": "VariableDeclaration",
    "signatures": ["const RECOMPUTE: '@ngrx/store-devtools/recompute';\n"],
    "information": []
  },
  {
    "module": "store-devtools",
    "api": "StoreDevtools",
    "kind": "ClassDeclaration",
    "signatures": [
      "class StoreDevtools implements Observer<any> {\n  public dispatcher: ActionsSubject;\n  public liftedState: Observable<LiftedState>;\n  public state: Observable<any>;\n\n  dispatch(action: Action);\n  next(action: any);\n  error(error: any);\n  complete();\n  performAction(action: any);\n  refresh();\n  reset();\n  rollback();\n  commit();\n  sweep();\n  toggleAction(id: number);\n  jumpToAction(actionId: number);\n  jumpToState(index: number);\n  importState(nextLiftedState: any);\n  lockChanges(status: boolean);\n  pauseRecording(status: boolean);\n}\n"
    ],
    "information": []
  },
  {
    "module": "store-devtools",
    "api": "StoreDevtoolsConfig",
    "kind": "ClassDeclaration",
    "signatures": [
      "class StoreDevtoolsConfig {\n  maxAge: number | false = false;\n  monitor?: ActionReducer<any, any>;\n  actionSanitizer?: ActionSanitizer;\n  stateSanitizer?: StateSanitizer;\n  name?: string;\n  serialize?: boolean | SerializationOptions;\n  logOnly?: boolean;\n  features?: DevToolsFeatureOptions;\n  actionsBlocklist?: string[];\n  actionsSafelist?: string[];\n  predicate?: Predicate;\n}\n"
    ],
    "information": []
  },
  {
    "module": "store-devtools",
    "api": "StoreDevtoolsOptions",
    "kind": "TypeAliasDeclaration",
    "signatures": [
      "type StoreDevtoolsOptions =\n  | Partial<StoreDevtoolsConfig>\n  | (() => Partial<StoreDevtoolsConfig>);\n"
    ],
    "information": []
  },
  {
    "module": "store-devtools",
    "api": "DevToolsFeatureOptions",
    "kind": "InterfaceDeclaration",
    "signatures": [
      "interface DevToolsFeatureOptions {\n  pause?: boolean;\n  lock?: boolean;\n  persist?: boolean;\n  export?: boolean;\n  import?: 'custom' | boolean;\n  jump?: boolean;\n  skip?: boolean;\n  reorder?: boolean;\n  dispatch?: boolean;\n  test?: boolean;\n}\n"
    ],
    "information": []
  },
  {
    "module": "store-devtools",
    "api": "INITIAL_OPTIONS",
    "kind": "VariableDeclaration",
    "signatures": [
      "const INITIAL_OPTIONS: InjectionToken<StoreDevtoolsConfig>;\n"
    ],
    "information": []
  }
]
